<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Never EndEver's Void Drifter ‚Äî Enhanced Edition</title>
    <!-- Force HTTPS for YouTube music player -->
    <script>
        // Allow HTTPS, localhost, or file:// protocol
        const isLocalHost = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
        const isLocalFile = location.protocol === 'file:' && location.hostname === '';
        
        if (location.protocol !== 'https:' && !isLocalHost && !isLocalFile) {
            location.replace('https:' + window.location.href.substring(window.location.protocol.length));
        }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0f;
            color: white;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            position: relative;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                linear-gradient(45deg, rgba(75, 0, 130, 0.3) 0%, rgba(138, 43, 226, 0.2) 25%, rgba(75, 0, 130, 0.1) 50%, rgba(25, 25, 112, 0.3) 75%, rgba(72, 61, 139, 0.2) 100%),
                radial-gradient(circle at 20% 30%, rgba(147, 0, 211, 0.4) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(75, 0, 130, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 40% 70%, rgba(138, 43, 226, 0.2) 0%, transparent 50%),
                radial-gradient(circle at 60% 80%, rgba(72, 61, 139, 0.3) 0%, transparent 40%);
            animation: spaceFloat 25s ease-in-out infinite;
            z-index: -2;
        }
        
        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(1px 1px at 25px 15px, #fff, transparent),
                radial-gradient(1px 1px at 75px 85px, rgba(255, 255, 255, 0.9), transparent),
                radial-gradient(1px 1px at 150px 30px, rgba(255, 255, 255, 0.7), transparent),
                radial-gradient(2px 2px at 45px 120px, rgba(255, 255, 255, 0.8), transparent),
                radial-gradient(1px 1px at 190px 75px, rgba(255, 255, 255, 0.6), transparent),
                radial-gradient(1px 1px at 95px 180px, rgba(255, 255, 255, 0.9), transparent),
                radial-gradient(2px 2px at 220px 140px, rgba(255, 255, 255, 0.7), transparent),
                radial-gradient(1px 1px at 35px 200px, rgba(255, 255, 255, 0.5), transparent),
                radial-gradient(1px 1px at 180px 10px, rgba(255, 255, 255, 0.8), transparent),
                radial-gradient(2px 2px at 110px 50px, rgba(255, 255, 255, 0.9), transparent),
                radial-gradient(1px 1px at 275px 90px, rgba(255, 255, 255, 0.6), transparent),
                radial-gradient(1px 1px at 65px 160px, rgba(255, 255, 255, 0.7), transparent),
                radial-gradient(2px 2px at 200px 200px, rgba(255, 255, 255, 0.8), transparent),
                radial-gradient(1px 1px at 140px 120px, rgba(255, 255, 255, 0.5), transparent),
                radial-gradient(1px 1px at 15px 90px, rgba(255, 255, 255, 0.9), transparent);
            background-repeat: repeat;
            background-size: 300px 250px;
            animation: starsFloat var(--star-speed, 60s) linear infinite;
            z-index: -1;
        }
        
        @keyframes spaceFloat {
            0%, 100% { 
                transform: translateY(0px) rotate(0deg) scale(1); 
                opacity: 0.8;
                filter: hue-rotate(0deg);
            }
            25% { 
                transform: translateY(-15px) rotate(1deg) scale(1.05); 
                opacity: 0.9;
                filter: hue-rotate(10deg);
            }
            50% { 
                transform: translateY(-5px) rotate(-0.5deg) scale(1.02); 
                opacity: 1;
                filter: hue-rotate(20deg);
            }
            75% { 
                transform: translateY(10px) rotate(0.5deg) scale(0.98); 
                opacity: 0.95;
                filter: hue-rotate(15deg);
            }
        }
        
        @keyframes starsFloat {
            0% {
                transform: translateX(0px) translateY(0px);
                opacity: var(--star-opacity-start, 0.8);
                filter: brightness(var(--star-brightness, 1));
            }
            25% {
                opacity: var(--star-opacity-mid, 1);
                filter: brightness(var(--star-brightness, 1)) hue-rotate(var(--star-hue, 0deg));
            }
            50% {
                opacity: var(--star-opacity-peak, 1.2));
                filter: brightness(var(--star-brightness, 1)) hue-rotate(var(--star-hue, 0deg));
            }
            75% {
                opacity: var(--star-opacity-mid, 1);
                filter: brightness(var(--star-brightness, 1)) hue-rotate(var(--star-hue, 0deg));
            }
            100% {
                transform: translateX(-300px) translateY(-250px);
                opacity: var(--star-opacity-end, 0.6);
                filter: brightness(var(--star-brightness, 1));
            }
        }

        #gameContainer {
            position: relative;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 100%);
            border: 2px solid #00f0ff;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 240, 255, 0.3);
            /* Add this to force centering if content overflows */
            margin: auto;
            top: 0; bottom: 0; left: 0; right: 0; /* Ensures margin:auto works with position:relative */
        }

        #gameCanvas {
            display: block;
            background: #0a0a0f;
        }

        /* Menu Styles */
        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh; /* Use 100vh for explicit viewport height */
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: flex-start; /* Ensure content starts from top */
            align-items: center;     /* Horizontal centering */
            z-index: 1000;
            overflow-y: hidden; /* Overlay itself should not scroll, content will */
            padding: 0;
            padding-bottom: 70px; /* Added to account for fixed footer's height */
            box-sizing: border-box;
        }
        
        /* Main menu gets special centering */
        #menuOverlay {
            justify-content: center;
            align-items: center;
            padding: 5px;
        }
        
        /* Scrollable menus for complex content */
        .menu-overlay.scrollable {
            /* This class no longer needs explicit justify-content, padding, overflow-y, or height as it inherits from .menu-overlay */
        }
        
        /* Ensure all menus can scroll */
        .menu-overlay::-webkit-scrollbar {
            width: 8px;
        }
        
        .menu-overlay::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }
        
        .menu-overlay::-webkit-scrollbar-thumb {
            background: rgba(0, 240, 255, 0.6);
            border-radius: 4px;
        }
        
        .menu-overlay::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 240, 255, 0.8);
        }
        
        .menu-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 800px;
            flex: 1; /* Takes up all available vertical space in its flex parent */
            padding: 10px;
            box-sizing: border-box;
            overflow-y: auto; /* This element is now explicitly scrollable */
            min-height: 0; /* Crucial for flex item with overflow to actually shrink and scroll */
            /* Removed max-height, as flex:1 with min-height:0 handles this */
        }
        /* Default max-width for elements within menu-content to prevent horizontal overflow */
        .menu-content > * {
            max-width: 100%;
            box-sizing: border-box;
        }

        .menu-title {
            font-size: clamp(1.2rem, 3.5vw, 1.8rem);
            color: #00f0ff;
            text-shadow: 0 0 30px #00f0ff, 0 0 60px #00f0ff;
            margin: 0.3rem 0 0.8rem 0;
            text-align: center;
            font-weight: bold;
            letter-spacing: 2px;
            flex-shrink: 0;
        }

        .menu-section {
            margin: 0.3rem 0;
            text-align: center;
            width: 100%;
            max-width: 600px;
            flex-shrink: 0;
        }

        .menu-label {
            color: #00f0ff;
            font-size: 1rem;
            margin-bottom: 0.3rem;
            display: block;
        }

        .menu-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .menu-btn, .difficulty-btn, .inhibitor-btn {
            padding: 8px 16px;
            background: linear-gradient(135deg, #00f0ff, #7c3aed);
            color: #000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            margin: 3px;
            font-size: 0.9rem;
        }

        .menu-btn:hover, .difficulty-btn:hover, .inhibitor-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 240, 255, 0.5);
        }

        .difficulty-btn.active, .inhibitor-btn.active {
            background: #00f0ff;
            box-shadow: 0 0 15px rgba(0, 240, 255, 0.7);
        }

        .inhibitor-btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .inhibitors-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 6px;
            max-width: 600px;
            width: 100%;
            margin: 0.5rem auto;
            max-height: 50vh;
            overflow-y: auto;
            padding: 15px;
            border: 1px solid rgba(0, 240, 255, 0.3);
            border-radius: 8px;
        }
        
        .inhibitors-grid::-webkit-scrollbar {
            width: 8px;
        }
        
        .inhibitors-grid::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }
        
        .inhibitors-grid::-webkit-scrollbar-thumb {
            background: rgba(0, 240, 255, 0.6);
            border-radius: 4px;
        }
        
        .inhibitors-grid::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 240, 255, 0.8);
        }

        .inhibitor-card {
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            text-align: left;
            cursor: pointer;
            transition: all 0.3s;
            min-height: 50px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .inhibitor-card:hover {
            border-color: #00f0ff;
            background: rgba(0, 240, 255, 0.1);
        }

        .inhibitor-card.selected {
            border-color: #00f0ff;
            background: rgba(0, 240, 255, 0.2);
            box-shadow: 0 0 15px rgba(0, 240, 255, 0.3);
        }

        .sortable-header:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .sortable-header.sorted-asc::after {
            content: ' ‚ñ≤';
            font-size: 0.8em;
        }
        .sortable-header.sorted-desc::after {
            content: ' ‚ñº';
            font-size: 0.8em;
        }

        .inhibitor-card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .inhibitor-name {
            font-size: 0.9rem;
            font-weight: bold;
            margin-bottom: 6px;
        }

        .inhibitor-desc {
            font-size: 0.7rem;
            opacity: 0.85;
            line-height: 1.2;
        }
        
        /* In-Game Inhibitor Menu */
        .ingame-inhibitor-menu {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00f0ff;
            border-radius: 8px;
            padding: 10px;
            min-width: 220px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 200;
            display: none;
        }
        
        .ingame-inhibitor-menu h3 {
            color: #00f0ff;
            margin: 0 0 10px 0;
            font-size: 1rem;
        }
        
        .ingame-inhibitor-item {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            padding: 6px 8px;
            margin: 4px 0;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.8rem;
        }
        
        .ingame-inhibitor-item:hover {
            border-color: #00f0ff;
            background: rgba(0, 240, 255, 0.1);
        }
        
        .ingame-inhibitor-item.selected {
            border-color: #00f0ff;
            background: rgba(0, 240, 255, 0.2);
        }

        /* HUD Styles */
        .hud {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            color: #00f0ff;
            font-size: 14px;
            font-weight: bold;
        }

        .hud-item {
            margin: 5px 0;
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #00f0ff;
            border-radius: 5px;
            display: inline-block;
            margin-right: 10px;
        }

        /* Music Controls - Draggable */
        .music-controls {
            position: fixed;
            bottom: 10px;
            left: 10px;
            right: auto; /* Ensure it doesn't conflict with left */
            height: 60px; /* Increased height */
            width: 450px; /* Increased width */
            z-index: 1200;
            display: flex;
            gap: 8px;
            align-items: center;
            background: rgba(0, 0, 0, 0.9);
            padding: 8px 12px;
            border-radius: 8px;
            border: 2px solid #00f0ff;
            max-width: 800px; /* Increased max-width for resizing */
            font-size: 12px;
            user-select: none;
            resize: both;
            overflow: auto;
            min-width: 260px;
            min-height: 44px;
        }
        
#preStartOverlay .menu-content {
            flex: 0 0 auto;
            min-height: auto;
            padding: 20px;
            align-items: center;
            justify-content: center;
            overflow: visible;
        }

        /* Music controls expand behavior */
        .music-controls .track-info { max-width: 260px; }
        .music-controls.expanded .track-info { max-width: none; }
        .music-controls.expanded .track-current,
        .music-controls.expanded .track-next { white-space: normal; }
        .music-controls .extra-info { display: none; font-size: 10px; color: #ccc; }
        .music-controls.expanded .extra-info { display: block; }

        .music-controls:hover {
            box-shadow: 0 0 15px rgba(0, 240, 255, 0.5);
        }
        
        .music-controls-header {
            position: absolute;
            top: -25px;
            left: 0;
            right: 0;
            height: 25px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00f0ff;
            border-radius: 4px 4px 0 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 8px;
            cursor: move;
            font-size: 10px;
            color: #00f0ff;
        }
        
        .music-controls-close {
            background: #ff4444;
            color: white;
            border: none;
            border-radius: 3px;
            width: 18px;
            height: 18px;
            cursor: pointer;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .music-controls-close:hover {
            background: #ff0000;
        }

        .music-btn {
            background: none;
            border: 1px solid #00f0ff;
            color: #00f0ff;
            padding: 3px 6px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            min-width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .music-btn:hover {
            background: rgba(0, 240, 255, 0.2);
        }

        .music-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .volume-slider {
            width: 60px;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }

        .track-info {
            font-size: 11px;
            max-width: 180px;
            color: #00f0ff;
            font-weight: bold;
            flex: 1;
            min-width: 0;
        }
        
        .track-current {
            margin-bottom: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .track-next {
            font-size: 9px;
            opacity: 0.7;
            color: #ffffff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Input field */
        .menu-input {
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00f0ff;
            border-radius: 5px;
            color: white;
            font-size: 1rem;
            margin: 10px;
            min-width: 200px;
        }

        .menu-input:focus {
            outline: none;
            box-shadow: 0 0 10px rgba(0, 240, 255, 0.5);
        }

        /* Ship customization */
        .ship-preview {
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #00f0ff;
            border-radius: 6px;
            margin: 3px auto;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .color-picker {
            width: 40px;
            height: 30px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }

        .ship-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            max-width: 250px;
            margin: 0 auto;
            font-size: 0.7rem;
        }

        .playlist-selector {
            max-width: 95vw;
            margin: 3px auto;
        }

        .playlist-option {
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            margin: 2px 0;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.8rem;
        }

        .playlist-option:hover {
            border-color: #00f0ff;
            background: rgba(0, 240, 255, 0.1);
        }

        .playlist-option.selected {
            border-color: #00f0ff;
            background: rgba(0, 240, 255, 0.2);
        }

        .warning-indicator {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: bold;
            z-index: 200;
            animation: pulse 0.5s infinite alternate;
        }

        @keyframes pulse {
            from { opacity: 0.8; transform: translateX(-50%) scale(1); }
            to { opacity: 1; transform: translateX(-50%) scale(1.05); }
        }
        
        /* Game Legend */
                                .game-legend {
                                    position: fixed; /* Use fixed for consistent positioning */
                                    bottom: 120px; /* Raised position for both */
                                    top: auto; /* Ensure no conflict with bottom */
                                    background: rgba(0, 0, 0, 0.8);
                                    border: 2px solid #00f0ff;
                                    border-radius: 8px;
                                    padding: 10px;
                                    font-size: 12px;
                                    color: #00f0ff;
                                    z-index: 150;
                                    max-height: calc(100vh - 120px); /* Max height to adapt to screen without overlap */
                                    overflow-y: auto; /* Re-enable scrolling if too tall */
                                    width: 350px; /* Fixed width for better readability */
                                }                        /* Specific positioning for left and right legends */
                                #gameLegendLeft {
                                    left: 10px;
                                    right: auto;
                                    transform: translateX(10%); /* Push inward slightly */
                                }
                                #gameLegendRight {
                                    right: 10px;
                                    left: auto;
                                    transform: translateX(-10%); /* Push inward slightly */
                                }                .legend-content-scrollable {
                    /* Removed max-height and overflow-y to allow dynamic sizing */
                    padding-right: 5px; /* Space for scrollbar (if it ever appears) */
                }
                .legend-content-scrollable::-webkit-scrollbar {
                    width: 5px;
                }
                .legend-content-scrollable::-webkit-scrollbar-track {
                    background: rgba(0, 240, 255, 0.1);
                    border-radius: 3px;
                }
                .legend-content-scrollable::-webkit-scrollbar-thumb {
                    background: rgba(0, 240, 255, 0.4);
                    border-radius: 3px;
                }
                .game-legend h3 {
                    color: #00f0ff;
                    text-align: center;
                    margin-bottom: 10px;
                    font-size: 1.1rem;
                }        .game-legend h4 {
            color: #7c3aed; /* Purple */
            margin-top: 15px;
            margin-bottom: 5px;
            font-size: 0.95rem;
            border-bottom: 1px solid rgba(124, 58, 237, 0.3);
            padding-bottom: 3px;
        }
        .game-legend ul {
            list-style: none;
            padding-left: 10px;
        }
        .game-legend li {
            margin-bottom: 3px;
            font-size: 0.8rem;
            line-height: 1.3;
        }
        .ally-status-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 5px;
            margin-top: 10px;
        }
        .ally-status-item {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(0, 240, 255, 0.2);
            padding: 5px 8px;
            border-radius: 5px;
            font-size: 0.8rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        /* HUD Toggle Button */
        .hud-toggle {
            transition: all 0.3s ease;
        }
        
        .hud-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(0, 240, 255, 0.5);
        }
        
        /* Ally customization slot styles */
        .ally-slot {
            background: rgba(0, 240, 255, 0.1);
            border: 1px solid rgba(0, 240, 255, 0.3);
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }
        
        .ally-slot h4 {
            color: #00f0ff;
            margin: 0 0 10px 0;
            font-size: 0.9rem;
        }
        
        /* Cursor preview */
        .cursor-preview {
            width: 80px;
            height: 80px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #00f0ff;
            border-radius: 6px;
            margin: 10px auto;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .legend-close {
            position: absolute;
            top: 5px;
            right: 8px;
            background: none;
            border: none;
            color: #ff4444;
            font-size: 16px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .legend-close:hover {
            color: #ff0000;
        }

        /* Back Button - Always Visible */
        .back-button-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.95);
            padding: 15px;
            border-top: 2px solid rgba(0, 240, 255, 0.5);
            z-index: 1100;
            backdrop-filter: blur(10px);
        }
        
        .back-button-container .menu-btn {
            width: 100%;
            max-width: 200px;
            margin: 0 auto;
            display: block;
        }
        
        /* Responsive Design */
        @media (max-width: 900px) {
            .menu-overlay {
                padding: 5px;
            }
            
            #menuOverlay {
                padding: 3px;
            }
            
            .menu-overlay.scrollable {
                padding: 10px;
                padding-top: 15px;
            }
            
            .menu-title {
                font-size: clamp(1rem, 3vw, 1.5rem);
                margin: 0.2rem 0 0.6rem 0;
            }
            
            .inhibitors-grid {
                grid-template-columns: 1fr;
                gap: 8px;
                max-height: 40vh;
            }
            
            .ship-controls {
                grid-template-columns: 1fr;
                gap: 8px;
                max-width: 300px;
            }
        }
        
        @media (max-width: 600px) {
            .menu-overlay {
                padding: 2px;
            }
            
            #menuOverlay {
                padding: 1px;
            }
            
            .menu-overlay.scrollable {
                padding: 5px;
                padding-top: 10px;
            }
            
            .menu-title {
                font-size: clamp(0.9rem, 2.5vw, 1.2rem);
                margin: 0.1rem 0 0.4rem 0;
            }
            
            .menu-section {
                margin: 0.2rem 0;
            }
            
            .menu-buttons {
                flex-direction: column;
                gap: 8px;
            }
            
            .menu-btn, .difficulty-btn, .inhibitor-btn {
                padding: 12px 20px;
                font-size: 0.9rem;
                min-height: 44px;
            }
            
            .inhibitors-grid {
                max-height: 35vh;
            }
            
            .music-controls {
                bottom: 5px;
                right: 5px;
                font-size: 10px;
                flex-wrap: wrap;
            }
            
            .playlist-option {
                font-size: 0.85rem;
                padding: 8px 12px;
            }
        }
        
        @media (max-height: 600px) {
            .menu-title {
                margin: 0.25rem 0 0.5rem 0;
            }
            
            .menu-section {
                margin: 0.25rem 0;
            }
            
            .inhibitors-grid {
                max-height: 30vh;
            }
        }
        
        @media (min-width: 1200px) {
            .inhibitors-grid {
                grid-template-columns: repeat(2, 1fr);
                max-width: 800px;
            }
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>
    <div id="damageOverlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255, 0, 0, 0.5); z-index: 2000; display: none; pointer-events: none;"></div>
    <div id="auth-container" style="position: fixed; top: 10px; right: 10px; z-index: 1001; display: flex; align-items: center; gap: 10px;">
        <div id="user-info" style="display: none; align-items: center; gap: 10px;">
            <span id="username" style="color: white; font-weight: bold;"></span>
            <div id="avatar" style="width: 30px; height: 30px; border-radius: 50%; background-color: #333; background-size: cover;"></div>
        </div>
        <button id="loginBtn" class="menu-btn">Login</button>
        <button id="signupBtn" class="menu-btn">Sign Up</button>
        <button id="logoutBtn" class="menu-btn" style="display: none;">Logout</button>
    </div>

    <div id="gameContainer">
        <canvas id="gameCanvas" width="1200" height="800"></canvas>
        
        <!-- User Agreement Overlay -->
        <div id="agreementOverlay" class="menu-overlay" style="background: rgba(0, 0, 0, 0.95);">
            <div class="menu-title" style="font-size: 1.8rem; margin-bottom: 2rem;">‚öñÔ∏è USER AGREEMENT</div>
            
            <div class="menu-section" style="max-width: 600px; text-align: left; font-size: 0.85rem; line-height: 1.4; margin: 0 auto 2rem;">
                <div style="background: rgba(0, 240, 255, 0.1); padding: 15px; border-radius: 8px; border: 1px solid rgba(0, 240, 255, 0.3);">
                    <h3 style="color: #00f0ff; margin: 0 0 10px 0; text-align: center;">üìú Terms of Use</h3>
                    
                    <p style="margin: 8px 0;">‚Ä¢ This game is <strong>open source</strong> and provided for <strong>educational and entertainment purposes only</strong></p>
                    
                    <p style="margin: 8px 0;">‚Ä¢ <strong>No commercial use</strong> - This game is not for sale and cannot be monetized</p>
                    
                    <p style="margin: 8px 0;">‚Ä¢ <strong>No warranty</strong> - Game is provided "as-is" with no guarantees</p>
                    
                    <p style="margin: 8px 0;">‚Ä¢ <strong>Third-party content</strong> - Music and some assets may belong to their respective creators</p>
                    
                    <p style="margin: 8px 0;">‚Ä¢ <strong>Fair use</strong> - By playing, you acknowledge this is a fan-made project</p>
                    
                    <p style="margin: 8px 0;">‚Ä¢ <strong>Modification rights</strong> - You may study and learn from the code, but please respect the creator's work</p>
                    
                    <div style="margin-top: 15px; padding: 10px; background: rgba(255, 215, 0, 0.1); border-radius: 5px; border: 1px solid rgba(255, 215, 0, 0.3);">
                        <p style="margin: 0; font-size: 0.8rem; color: #ffd700; text-align: center;">üéÆ <strong>Created by Fu2</strong> üéÆ</p>
                    </div>
                </div>
            </div>
            
            <div style="margin-top: 20px; padding: 15px; background: rgba(255, 0, 0, 0.15); border-radius: 8px; border: 1px solid rgba(255, 0, 0, 0.4); max-width: 600px; margin: 0 auto 2rem;">
                <h4 style="color: #ff4444; margin: 0 0 10px 0; text-align: center;">‚ö†Ô∏è Photosensitivity & Seizure Warning</h4>
                <p style="font-size: 0.8rem; text-align: center; line-height: 1.4;">This game contains bright flashing lights, rapidly changing colors, and other visual effects that may trigger seizures in individuals with photosensitive epilepsy.</p>
            </div>

            <div class="menu-section">
                <label style="display: flex; align-items: center; justify-content: center; gap: 10px; font-size: 1rem; cursor: pointer;">
                    <input type="checkbox" id="disableFlashesCheck" style="transform: scale(1.3);">
                    <span>Disable Flashing Effects (for photosensitivity)</span>
                </label>
            </div>
            
            <div class="menu-section">
                <label style="display: flex; align-items: center; justify-content: center; gap: 10px; font-size: 1rem; cursor: pointer;">
                    <input type="checkbox" id="agreementCheck" style="transform: scale(1.3);">
                    <span>I understand and agree to these terms</span>
                </label>
            </div>
            
            <div class="menu-section">
                <button id="acceptAgreementBtn" class="menu-btn" disabled style="opacity: 0.5;">ENTER VOID DRIFTER</button>
            </div>
        </div>

        <!-- Menu Overlay -->
        <div id="menuOverlay" class="menu-overlay" style="display: none;">
            <h1 class="menu-title">NEVER ENDEVER'S VOID DRIFTER</h1>
            
            <div class="menu-section">
                <label class="menu-label">Player Name:</label>
                <input type="text" id="playerNameInput" class="menu-input" placeholder="Enter your name" value="Player">
            </div>
            
            
            <div class="menu-section">
                <label class="menu-label">‚≠ê Ship Design:</label>
                <div class="ship-preview" id="shipPreview"></div>
                <div class="ship-controls">
                    <label>Shape:
                        <select id="shipShape" class="menu-input" style="min-width: 70px; font-size: 11px; padding: 4px;">
                            <option value="triangle">Triangle</option>
                            <option value="diamond">Diamond</option>
                            <option value="arrow">Arrow</option>
                            <option value="star">Star</option>
                            <option value="circle">Circle</option>
                        </select>
                    </label>
                    <label>Body:
                        <input type="color" id="shipBodyColor" class="color-picker" value="#ffffff" style="width: 35px; height: 25px;">
                    </label>
                    <label>Accent:
                        <input type="color" id="shipAccentColor" class="color-picker" value="#00f0ff" style="width: 35px; height: 25px;">
                    </label>
                </div>
            </div>
            
            <div class="menu-section">
                <label class="menu-label">‚öîÔ∏è Difficulty:</label>
                <div class="menu-buttons">
                    <button class="difficulty-btn" data-difficulty="easy">Easy</button>
                    <button class="difficulty-btn active" data-difficulty="normal">Normal</button>
                    <button class="difficulty-btn" data-difficulty="hard">Hard</button>
                </div>
            </div>
            
            
            <div class="menu-section">
                <button id="customizationBtn" class="menu-btn">üé® CUSTOMIZATION</button>
            </div>
            
            
            <div class="menu-section" style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; max-width: 400px; margin: 0 auto;">
                <button id="startGameBtn" class="menu-btn" style="grid-column: 1 / -1; font-size: 1.2rem; padding: 15px;">START GAME</button>
                <button id="leaderboardBtn" class="menu-btn">üèÜ LEADERBOARD</button>
                <button id="settingsBtn" class="menu-btn">‚öôÔ∏è SETTINGS</button>
            </div>
        </div>

        <!-- Pre-Start Overlay -->
        <div id="preStartOverlay" class="menu-overlay" style="display: none;">
            <div class="menu-content" style="max-width: 500px;">
                <h2 class="menu-title">PRE-GAME SETUP</h2>
                <div class="menu-section">
                    <div class="menu-buttons">
                        <button id="inhibitorsBtn" class="menu-btn">üíä INHIBITORS</button>
                        <button id="alliesBtn" class="menu-btn">üë• ALLIES</button>
                    </div>
                </div>
                <div class="menu-section">
                    <button id="preStartStartBtn" class="menu-btn" style="font-size: 1.1rem; padding: 12px 18px;">START GAME</button>
                </div>
                <div class="menu-section">
                    <button id="preStartBackBtn" class="menu-btn">BACK</button>
                </div>
            </div>
        </div>

        <!-- Settings Overlay -->
        <div id="settingsOverlay" class="menu-overlay scrollable" style="display: none;">
            <div class="menu-content">
                <h2 class="menu-title">SETTINGS</h2>
                
                <div class="menu-section">
                    <label class="menu-label">Music Volume: <span id="musicVolumeValue">50</span>%</label>
                    <input type="range" id="musicVolumeSlider" class="volume-slider" min="0" max="100" value="50" style="width: 200px;">
                </div>
                
                <div class="menu-section">
                    <label class="menu-label">SFX Volume: <span id="sfxVolumeValue">70</span>%</label>
                    <input type="range" id="sfxVolumeSlider" class="volume-slider" min="0" max="100" value="70" style="width: 200px;">
                </div>
                
                <div class="menu-section">
                    <label class="menu-label">Music Reactivity: <span id="reactivityValue">50</span>%</label>
                    <input type="range" id="reactivitySlider" class="volume-slider" min="0" max="100" value="50" style="width: 200px;">
                </div>
                
                <div class="menu-section">
                    <label class="menu-label">FPS Limit:</label>
                    <div class="menu-buttons">
                        <button class="difficulty-btn" data-fps-limit="30">30 FPS</button>
                        <button class="difficulty-btn" data-fps-limit="60">60 FPS</button>
                        <button class="difficulty-btn" data-fps-limit="120">120 FPS</button>
                        <button class="difficulty-btn active" data-fps-limit="unlimited">Unlimited</button>
                    </div>
                </div>
                
                <div class="menu-section">
                    <label class="menu-label">Graphics Quality:</label>
                    <div class="menu-buttons">
                        <button class="difficulty-btn" data-particles="low">Low Particles</button>
                        <button class="difficulty-btn" data-particles="medium">Medium Particles</button>
                        <button class="difficulty-btn active" data-particles="high">High Particles</button>
                    </div>
                </div>
                
                <div class="menu-section">
                    <label class="menu-label">Visual Options:</label>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; max-width: 300px; margin: 0 auto;">
                        <label style="display: flex; align-items: center; gap: 5px;">
                            <input type="checkbox" id="showGridEnabledSettings" checked>
                            Show Grid
                        </label>
                        <label style="display: flex; align-items: center; gap: 5px;">
                            <input type="checkbox" id="screenShakeEnabledSettings" checked>
                            Screen Shake
                        </label>
                        <label style="display: flex; align-items: center; gap: 5px;">
                            <input type="checkbox" id="visualEffectsEnabledSettings" checked>
                            Visual Effects
                        </label>
                        <label style="display: flex; align-items: center; gap: 5px;">
                            <input type="checkbox" id="particleEffectsEnabledSettings" checked>
                            Particle Effects
                        </label>
                    </div>
                </div>
                
                <div class="menu-section">
                    <label class="menu-label">Visual Effects:</label>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; max-width: 300px; margin: 0 auto;">
                        <label style="display: flex; align-items: center; gap: 5px;">
                            <input type="checkbox" id="colorPulseEnabled" checked>
                            Color Pulse
                        </label>
                        <label style="display: flex; align-items: center; gap: 5px;">
                            <input type="checkbox" id="backgroundReactEnabled" checked>
                            Background React
                        </label>
                        <label style="display: flex; align-items: center; gap: 5px;">
                            <input type="checkbox" id="trippyEffectsEnabled" checked>
                            Trippy Effects
                        </label>
                        <label style="display: flex; align-items: center; gap: 5px;">
                            <input type="checkbox" id="tailWarningEnabled" checked>
                            Tail Warnings
                        </label>
                        <label style="display: flex; align-items: center; gap: 5px;">
                            <input type="checkbox" id="backgroundAnimationEnabled" checked>
                            Background Animation
                        </label>
                        <label style="display: flex; align-items: center; gap: 5px;">
                            <input type="checkbox" id="backgroundMovementEnabled" checked>
                            Background Movement
                        </label>
                    </div>
                </div>
                
                <div class="menu-section">
                    <label class="menu-label">Shooting Mode:</label>
                    <div class="menu-buttons">
                        <button class="difficulty-btn active" data-shooting="hold">Hold</button>
                        <button class="difficulty-btn" data-shooting="click">Click</button>
                    </div>
                </div>
                <div class="menu-section">
                    <button id="restoreDefaultsBtn" class="menu-btn" style="background: #00ff00;">üîÑ RESTORE HIGH QUALITY DEFAULTS</button>
                    <button id="fullscreenBtn" class="menu-btn"> expand_less FULL SCREEN</button>
                </div>
                
                <div class="menu-section">
                    <button id="creditsBtn" class="menu-btn">üìú CREDITS</button>
                </div>
            </div>
            
            <div class="menu-section">
                <label class="menu-label">HUD:</label>
                <label style="display: flex; align-items: center; justify-content: center; gap: 8px;">
                    <input type="checkbox" id="hudAutoHideToggle">
                    Auto-hide HUD after game start and show briefly on level-ups
                </label>
            </div>
            
            <div class="back-button-container">
                <button id="backFromSettingsBtn" class="menu-btn">BACK</button>
            </div>
        </div>
        

        <!-- Leaderboard Overlay -->
        <div id="leaderboardOverlay" class="menu-overlay" style="display: none;">
            <h2 class="menu-title">üèÜ LEADERBOARD</h2>
            <div class="menu-section">
                <div class="menu-buttons" style="margin-bottom: 15px;">
                    <button class="leaderboard-filter-btn menu-btn active" data-difficulty="all">All</button>
                    <button class="leaderboard-filter-btn menu-btn" data-difficulty="easy">Easy</button>
                    <button class="leaderboard-filter-btn menu-btn" data-difficulty="normal">Normal</button>
                    <button class="leaderboard-filter-btn menu-btn" data-difficulty="hard">Hard</button>
                </div>
                <div id="leaderboardContent" style="max-width: 600px; margin: 0 auto;">
                    <div style="background: rgba(0,0,0,0.5); padding: 15px; border-radius: 8px; max-height: 60vh; overflow-y: auto;">
                        <table style="width: 100%; color: white; font-size: 0.9rem;">
                            <thead>
                                <tr style="border-bottom: 1px solid #00f0ff;">
                                    <th style="padding: 8px; text-align: left;">Rank</th>
                                    <th style="padding: 8px; text-align: left;">Name</th>
                                    <th class="sortable-header" data-sort="score" style="padding: 8px; text-align: right; cursor: pointer;">Score</th>
                                    <th class="sortable-header" data-sort="level" style="padding: 8px; text-align: center; cursor: pointer;">Level</th>
                                    <th class="sortable-header" data-sort="kills" style="padding: 8px; text-align: center; cursor: pointer;">Kills</th>
                                    <th class="sortable-header" data-sort="deaths" style="padding: 8px; text-align: center; cursor: pointer;">Deaths</th>
                                    <th class="sortable-header" data-sort="accuracy" style="padding: 8px; text-align: center; cursor: pointer;">Accuracy</th>
                                    <th class="sortable-header" data-sort="wave" style="padding: 8px; text-align: center; cursor: pointer;">Wave</th>
                                    <th class="sortable-header" data-sort="difficulty" style="padding: 8px; text-align: center; cursor: pointer;">Difficulty</th>
                                    <th class="sortable-header" data-sort="num_allies" style="padding: 8px; text-align: center; cursor: pointer;">Allies</th>
                                    <th style="padding: 8px; text-align: center;">Details</th>
                                </tr>
                            </thead>
                            <tbody id="leaderboardTable">
                                <!-- Populated by JavaScript -->
                            </tbody>
                        </table>
                        <div id="noScoresMessage" style="text-align: center; padding: 20px; color: #888; display: none;">
                            No scores yet. Play a game to set your first record!
                        </div>
                    </div>
                </div>
            </div>
            <div class="menu-section">
                <button id="backFromLeaderboardBtn" class="menu-btn">BACK</button>
            </div>
        </div>

        <!-- Game Over Overlay -->
        <div id="gameOverOverlay" class="menu-overlay" style="display: none;">
            <h2 class="menu-title">GAME OVER</h2>
            <div class="menu-section">
                <div style="font-size: 1.5rem; margin: 20px 0;">
                    Final Score: <span id="finalScore" style="color: #00f0ff;">0</span>
                </div>
                <div style="margin: 10px 0;">
                    Wave: <span id="finalWave">1</span> | Level: <span id="finalLevel">1</span>
                </div>
                <div id="newHighScore" style="color: #ffaa00; font-weight: bold; margin: 10px 0; display: none;">
                    üèÜ NEW HIGH SCORE! üèÜ
                </div>
            </div>
            <div class="menu-section">
                <button id="playAgainBtn" class="menu-btn">PLAY AGAIN</button>
                <button id="viewLeaderboardBtn" class="menu-btn">VIEW LEADERBOARD</button>
                <button id="mainMenuBtn" class="menu-btn">MAIN MENU</button>
            </div>
        </div>

        <!-- Pause Overlay -->
        <div id="pauseOverlay" class="menu-overlay" style="display: none;">
            <h2 class="menu-title">PAUSED</h2>
            <div class="menu-section">
                <button id="resumeBtn" class="menu-btn">RESUME</button>
                <button id="tutorialBtn" class="menu-btn">TUTORIAL</button>
                <button id="pauseCustomizationBtn" class="menu-btn">üé® CUSTOMIZATION</button>
                <button id="pauseSettingsBtn" class="menu-btn">SETTINGS</button>
                <button id="quitBtn" class="menu-btn">QUIT</button>
            </div>
        </div>
        
        <!-- Inhibitors Overlay -->
        <div id="inhibitorsOverlay" class="menu-overlay scrollable" style="display: none;">
            <div class="menu-content">
            <h2 class="menu-title">üíä INHIBITORS</h2>
            <div class="menu-section">
                <label class="menu-label">Select inhibitors (some can stack!):</label>
                <div style="font-size: 0.8rem; color: #888; margin-bottom: 10px;">Click multiple times on stackable inhibitors for stronger effects</div>
                <div class="inhibitors-grid" id="inhibitorsGrid">
                    <!-- Inhibitors will be populated by JavaScript -->
                </div>
            </div>
            <div class="menu-section">
                <button id="clearInhibitorsBtn" class="menu-btn" style="background: #ff4444;">CLEAR ALL</button>
            </div>
            
            </div>
            <div class="back-button-container">
                <button id="backFromInhibitorsBtn" class="menu-btn">BACK</button>
            </div>
        </div>
        
        <!-- Customization Overlay -->
        <div id="customizationOverlay" class="menu-overlay scrollable" style="display: none;">
            <div class="menu-content">
            <h2 class="menu-title">üé® CUSTOMIZATION</h2>
            
            <!-- Ship Customization -->
            <div class="menu-section">
                <label class="menu-label">‚≠ê SHIP DESIGN</label>
                <div class="ship-preview" id="shipPreviewCustom"></div>
                <div class="ship-controls">
                    <label>Shape:
                        <select id="shipShapeCustom" class="menu-input" style="min-width: 70px; font-size: 11px; padding: 4px;">
                            <option value="triangle">Triangle</option>
                            <option value="diamond">Diamond</option>
                            <option value="arrow">Arrow</option>
                            <option value="star">Star</option>
                            <option value="circle">Circle</option>
                        </select>
                    </label>
                    <label>Body:
                        <input type="color" id="shipBodyColorCustom" class="color-picker" value="#ffffff" style="width: 35px; height: 25px;">
                    </label>
                    <label>Accent:
                        <input type="color" id="shipAccentColorCustom" class="color-picker" value="#00f0ff" style="width: 35px; height: 25px;">
                    </label>
                </div>
            </div>
            
            <!-- Tail Customization -->
            <div class="menu-section">
                <label class="menu-label">üåü TAIL CUSTOMIZATION</label>
                <div class="ship-preview" id="tailPreview" style="background: rgba(0,0,0,0.9); width: 150px; height: 80px;">
                    <!-- Tail preview will be rendered here -->
                </div>
                <div style="display: grid; grid-template-columns: 1fr; gap: 10px; max-width: 300px; margin: 10px auto;">
                    <label>Width: <span id="tailWidthValue">3</span>
                        <input type="range" id="tailWidthSlider" class="volume-slider" min="1" max="8" value="3" style="width: 150px;">
                    </label>
                    <label>Glow: <span id="tailGlowValue">50</span>%
                        <input type="range" id="tailGlowSlider" class="volume-slider" min="0" max="100" value="50" style="width: 150px;">
                    </label>
                    <label>Color:
                        <input type="color" id="tailColorPicker" class="color-picker" value="#00f0ff" style="width: 60px; height: 30px;">
                    </label>
                </div>
            </div>
            
            <!-- Cursor/Crosshair Customization -->
            <div class="menu-section">
                <label class="menu-label">üéØ CURSOR & TARGETING</label>
                <div style="display: grid; grid-template-columns: 1fr; gap: 10px; max-width: 350px; margin: 10px auto;">
                    <label style="display: flex; align-items: center; gap: 10px; justify-content: space-between;">
                        Enable Cursor:
                        <input type="checkbox" id="cursorEnabledToggle" style="transform: scale(1.2);">
                    </label>
                    
                    <label>Cursor Type:
                        <select id="cursorTypeSelect" class="menu-input" style="min-width: 100px; font-size: 11px; padding: 4px;">
                            <option value="cross">Cross</option>
                            <option value="dot">Dot</option>
                            <option value="circle">Circle</option>
                            <option value="target">Target</option>
                        </select>
                    </label>
                    
                    <label>Cursor Size: <span id="cursorSizeValue">20</span>px
                        <input type="range" id="cursorSizeSlider" class="volume-slider" min="10" max="50" value="20" style="width: 150px;">
                    </label>
                    
                    <label>Cursor Color:
                        <input type="color" id="cursorColorPicker" class="color-picker" value="#00ff00" style="width: 60px; height: 30px;">
                    </label>
                    
                    <label>Cursor Opacity: <span id="cursorOpacityValue">80</span>%
                        <input type="range" id="cursorOpacitySlider" class="volume-slider" min="10" max="100" value="80" style="width: 150px;">
                    </label>
                </div>
            </div>
            
            <!-- Mouse Sensitivity -->
            <div class="menu-section">
                <label class="menu-label">üñ±Ô∏è MOUSE SENSITIVITY & WEAPONS</label>
                <div style="max-width: 300px; margin: 0 auto;">
                    <label>Ship Rotation Sensitivity: <span id="mouseSensitivityValue">100</span>%
                        <input type="range" id="mouseSensitivitySlider" class="volume-slider" min="10" max="500" value="100" style="width: 200px;">
                    </label>
                </div>
                    <div style="font-size: 0.8rem; color: #888; margin-top: 5px; text-align: center;">
                        Lower = slower turns, Higher = faster turns
                    </div>
                    
                    <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid rgba(0, 240, 255, 0.3);">
                        <label style="display: flex; align-items: center; gap: 10px; justify-content: space-between;">
                            Hold Mode for Secondary Weapon:
                            <input type="checkbox" id="secondaryHoldModeToggle" style="transform: scale(1.2);">
                        </label>
                        <div style="font-size: 0.75rem; color: #888; margin-top: 5px; text-align: center;">
                            Hold = slower charge but continuous ‚Ä¢ Tap = rapid fire
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Ammo Customization -->
            <div class="menu-section">
                <label class="menu-label">üéØ AMMO CUSTOMIZATION</label>
                
                <div style="margin: 10px 0;">
                    <label class="menu-label" style="font-size: 0.9rem;">Ammo Type:</label>
                    <div class="menu-buttons">
                        <button class="difficulty-btn active" data-ammo-type="standard" style="font-size: 0.8rem; padding: 8px 12px;">Standard</button>
                        <button class="difficulty-btn" data-ammo-type="piercing" style="font-size: 0.8rem; padding: 8px 12px;">Piercing</button>
                        <button class="difficulty-btn" data-ammo-type="explosive" style="font-size: 0.8rem; padding: 8px 12px;">Explosive</button>
                        <button class="difficulty-btn" data-ammo-type="spread" style="font-size: 0.8rem; padding: 8px 12px;">Spread</button>
                    </div>
                </div>
                
                <div style="margin: 10px 0;">
                    <label class="menu-label" style="font-size: 0.9rem;">Ammo Size:</label>
                    <div class="menu-buttons">
                        <button class="difficulty-btn" data-ammo-size="small" style="font-size: 0.7rem; padding: 6px 10px;">Small (Fast)</button>
                        <button class="difficulty-btn active" data-ammo-size="medium" style="font-size: 0.7rem; padding: 6px 10px;">Medium</button>
                        <button class="difficulty-btn" data-ammo-size="large" style="font-size: 0.7rem; padding: 6px 10px;">Large (Slow)</button>
                    </div>
                </div>
                
                <div style="margin: 10px 0;">
                    <label class="menu-label" style="font-size: 0.9rem;">Ammo Color:</label>
                    <div style="display: flex; gap: 5px; justify-content: center; flex-wrap: wrap;">
                        <button class="difficulty-btn active" data-ammo-color="#00f0ff" style="background: #00f0ff; color: black; font-size: 0.7rem; padding: 4px 8px;">Cyan</button>
                        <button class="difficulty-btn" data-ammo-color="#ff0080" style="background: #ff0080; color: white; font-size: 0.7rem; padding: 4px 8px;">Pink</button>
                        <button class="difficulty-btn" data-ammo-color="#00ff00" style="background: #00ff00; color: black; font-size: 0.7rem; padding: 4px 8px;">Green</button>
                        <button class="difficulty-btn" data-ammo-color="#ffff00" style="background: #ffff00; color: black; font-size: 0.7rem; padding: 4px 8px;">Yellow</button>
                        <button class="difficulty-btn" data-ammo-color="#ff4444" style="background: #ff4444; color: white; font-size: 0.7rem; padding: 4px 8px;">Red</button>
                        <button class="difficulty-btn" data-ammo-color="#8844ff" style="background: #8844ff; color: white; font-size: 0.7rem; padding: 4px 8px;">Purple</button>
                    </div>
                </div>
                
                <div class="ship-preview" id="ammoPreview" style="background: rgba(0,0,0,0.8); width: 100px; height: 60px;">
                    <!-- Ammo preview will be rendered here -->
                </div>
            </div>
            
            </div>
            <div class="back-button-container">
                <button id="backFromCustomizationBtn" class="menu-btn">BACK</button>
            </div>
        </div>
        
        <!-- Allies Overlay -->
        <div id="alliesOverlay" class="menu-overlay" style="display: none;">
            <h2 class="menu-title">üë• ALLIES CONFIGURATION</h2>
            
            <div class="menu-section">
                <label class="menu-label">Number of Allied Ships:</label>
                <div class="menu-buttons">
                    <button class="difficulty-btn" data-ally-count="0">None</button>
                    <button class="difficulty-btn" data-ally-count="1">1 Ally</button>
                    <button class="difficulty-btn active" data-ally-count="2">2 Allies</button>
                    <button class="difficulty-btn" data-ally-count="3">3 Allies</button>
                    <button class="difficulty-btn" data-ally-count="4">4 Allies</button>
                </div>
            </div>
            
            <div class="menu-section">
                <label class="menu-label">Ally AI Behavior:</label>
                <div class="menu-buttons">
                    <button class="difficulty-btn" data-ally-behavior="defensive">Defensive (Stay Close)</button>
                    <button class="difficulty-btn active" data-ally-behavior="balanced">Balanced</button>
                    <button class="difficulty-btn" data-ally-behavior="aggressive">Aggressive (Hunt Enemies)</button>
                </div>
            </div>
            
            <div class="menu-section">
                <button id="allyCustomizationBtn" class="menu-btn">üé® ALLY CUSTOMIZATION</button>
                <button id="backFromAlliesBtn" class="menu-btn">BACK</button>
            </div>
        </div>
        
        <!-- Ally Customization Overlay -->
        <div id="allyCustomizationOverlay" class="menu-overlay scrollable" style="display: none;">
            <div class="menu-content">
            <h2 class="menu-title">üé® ALLY CUSTOMIZATION</h2>
            
            <!-- Individual Ally Slots -->
            <div class="menu-section" id="allyCustomizationSlots">
                <label class="menu-label">Customize Individual Allies:</label>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; max-width: 800px; margin: 0 auto;">
                    <!-- Ally slots will be populated dynamically -->
                </div>
            </div>
            
            <div class="menu-section">
                <label class="menu-label">Display Options:</label>
                <label style="display: flex; align-items: center; justify-content: center; gap: 8px;">
                    <input type="checkbox" id="allyNamesToggleCustom" checked>
                    Show ally names above their ships
                </label>
            </div>
            <!-- Global Ally Settings -->
            <div class="menu-section">
                <label class="menu-label">Global Ally Settings:</label>
                <div style="background: rgba(0, 240, 255, 0.1); padding: 15px; border-radius: 8px; border: 1px solid rgba(0, 240, 255, 0.3); max-width: 400px; margin: 0 auto;">
                    <label style="display: flex; align-items: center; justify-content: space-between; margin: 8px 0;">
                        Ally HP Multiplier: <span id="allyHpMultiplierValue">100</span>%
                        <input type="range" id="allyHpMultiplier" class="volume-slider" min="50" max="200" value="100" style="width: 120px;">
                    </label>
                    <label style="display: flex; align-items: center; justify-content: space-between; margin: 8px 0;">
                        Ally Damage Multiplier: <span id="allyDamageMultiplierValue">100</span>%
                        <input type="range" id="allyDamageMultiplier" class="volume-slider" min="50" max="200" value="100" style="width: 120px;">
                    </label>
                    <label style="display: flex; align-items: center; justify-content: space-between; margin: 8px 0;">
                        Ally Speed Multiplier: <span id="allySpeedMultiplierValue">100</span>%
                        <input type="range" id="allySpeedMultiplier" class="volume-slider" min="50" max="150" value="100" style="width: 120px;">
                    </label>
                </div>
            </div>
            
            </div>
            <div class="back-button-container">
                <button id="backFromAllyCustomizationBtn" class="menu-btn">BACK</button>
            </div>
        </div>
        
        <!-- Tutorial Overlay -->
        <div id="tutorialOverlay" class="menu-overlay" style="display: none;">
            <h2 class="menu-title">HOW TO PLAY</h2>
            <div class="menu-section" style="text-align: left; max-width: 600px; font-size: 0.9rem;">
                <h3 style="color: #00f0ff; margin-bottom: 10px;">üéØ CONTROLS:</h3>
                <p>‚Ä¢ <strong>WASD/Arrow Keys:</strong> Move your ship</p>
                <p>‚Ä¢ <strong>Mouse:</strong> Aim direction</p>
                <p>‚Ä¢ <strong>Left Click:</strong> Fire primary weapon</p>
                <p>‚Ä¢ <strong>Right Click/Hold:</strong> Charge secondary weapon</p>
                <p>‚Ä¢ <strong>Shift/Space:</strong> Boost (limited fuel)</p>
                <p>‚Ä¢ <strong>Mouse Wheel:</strong> Change ammo type (Standard/Piercing/Explosive/Spread)</p>
                <p>‚Ä¢ <strong>I:</strong> Toggle inhibitor menu (in-game)</p>
                <p>‚Ä¢ <strong>M:</strong> Play/Pause music</p>
                <p>‚Ä¢ <strong>Tab:</strong> Skip song</p>
                <p>‚Ä¢ <strong>P/Esc:</strong> Pause game</p>
                
                <h3 style="color: #00f0ff; margin: 15px 0 10px 0;">‚ö° GAMEPLAY:</h3>
                <p>‚Ä¢ Your <strong>tail</strong> damages enemies - use it as a weapon!</p>
                <p>‚Ä¢ <strong>Bullets bounce</strong> off walls once before disappearing</p>
                <p>‚Ä¢ <strong>Bullet impacts</strong> create grid warp effects</p>
                <p>‚Ä¢ Avoid touching your own tail (causes damage)</p>
                <p>‚Ä¢ Different enemy types have unique behaviors</p>
                <p>‚Ä¢ Collect points to advance waves and levels</p>
                <p>‚Ä¢ <strong>Inhibitors</strong> give special powers and effects</p>
                <p>‚Ä¢ <strong>Allies</strong> fight alongside you (configure in menu)</p>
                
                <h3 style="color: #00f0ff; margin: 15px 0 10px 0;">üöÄ TIPS:</h3>
                <p>‚Ä¢ Use walls to ricochet shots around corners</p>
                <p>‚Ä¢ Your tail grows longer and more powerful over time</p>
                <p>‚Ä¢ Secondary weapon deals massive damage when charged</p>
                <p>‚Ä¢ Watch for bomber warnings - they explode!</p>
                <p>‚Ä¢ Change ammo types on the fly with mouse wheel</p>
                <p>‚Ä¢ Use 'I' key to adjust inhibitors mid-game</p>
            </div>
            <div class="menu-section">
                <button id="closeTutorialBtn" class="menu-btn">GOT IT!</button>
            </div>
        </div>
        
        <!-- HUD -->
        <div id="hud" class="hud" style="display: none;">
            <div class="hud-item">Total Score: <span id="scoreDisplay">0</span></div>
            <div class="hud-item">Personal Score: <span id="personalScoreDisplay">0</span></div>
            <div class="hud-item">Team Score: <span id="teamScoreDisplay">0</span></div>
            <div class="hud-item">Wave: <span id="waveDisplay">1</span></div>
            <div class="hud-item">Level: <span id="levelDisplay">1</span></div>
            <div class="hud-item">HP: <span id="hpDisplay">100</span>/<span id="maxHpDisplay">100</span></div>
            <div class="hud-item">Boost: <span id="boostDisplay">100</span>%</div>
            <div class="hud-item">Enemies: <span id="enemyCountDisplay">0</span></div>
        </div>
        
        <!-- Tail Warning -->
        <div id="tailWarning" class="warning-indicator" style="display: none;">‚ö†Ô∏è TAIL COLLISION IMMINENT!</div>
        
        <!-- Game Legend Left -->
        <div id="gameLegendLeft" class="game-legend" style="display: none;">
            <button class="legend-close" id="closeLegendLeft">√ó</button>
            <h3>Controls & Gameplay Tips</h3>
            <div class="legend-content-scrollable">
                <section>
                    <h4>üéÆ CONTROLS</h4>
                    <ul>
                        <li><strong>WASD / Arrows:</strong> Move Ship</li>
                        <li><strong>Mouse:</strong> Aim Direction</li>
                        <li><strong>Left Click:</strong> Fire Primary Weapon</li>
                        <li><strong>Right Click / Hold:</strong> Charge Secondary Weapon</li>
                        <li><strong>Shift / Space:</strong> Boost (limited fuel)</li>
                        <li><strong>Mouse Wheel:</strong> Change Ammo Type</li>
                        <li><strong>I:</strong> Toggle Inhibitor Menu (in-game)</li>
                        <li><strong>M:</strong> Play/Pause Music</li>
                        <li><strong>Tab:</strong> Skip Song</li>
                        <li><strong>P / Esc:</strong> Pause Game</li>
                        <li><strong>Back Button (any menu):</strong> Pause/Return to Previous Menu</li>
                    </ul>
                </section>
                <section>
                    <h4>‚ö° GAMEPLAY TIPS</h4>
                    <ul>
                        <li>Your <strong>tail</strong> damages enemies ‚Äì use it as a weapon!</li>
                        <li>Bullets bounce off walls once. Use it to your advantage.</li>
                        <li>Avoid touching your own tail (causes damage).</li>
                        <li>Collect power-ups dropped by enemies (Health, Shield, Weapon Boost).</li>
                        <li>Allies will assist you, even picking up power-ups!</li>
                        <li>Different enemy types have unique behaviors.</li>
                        <li><strong>Inhibitors</strong> in Pre-Game Setup offer unique buffs/debuffs.</li>
                    </ul>
                </section>
            </div>
        </div>

        <!-- Game Legend Right -->
        <div id="gameLegendRight" class="game-legend" style="display: none;">
            <button class="legend-close" id="closeLegendRight">√ó</button>
            <h3>Allies Status</h3>
            <div class="legend-content-scrollable">
                <section>
                    <h4>üë• ALLIES STATUS</h4>
                    <div id="allyStatus" class="ally-status-grid">
                        <!-- Allies will be populated by JavaScript -->
                    </div>
                    <p style="font-size: 0.75rem; color: #888; text-align: center; margin-top: 10px;">Ally scores reflect their contribution to team score.</p>
                </section>
            </div>
        </div>
        
        <!-- Music Controls - Draggable -->
        <div id="musicControls" class="music-controls">
            <div class="music-controls-header">
                <span>üéµ Music</span>
                <button id="closeMusicBtn" class="music-controls-close">√ó</button>
            </div>
            <button id="prevBtn" class="music-btn" disabled>‚èÆ</button>
            <button id="playPauseBtn" class="music-btn" disabled>‚ñ∂</button>
            <button id="nextBtn" class="music-btn" disabled>‚è≠</button>
            <button id="shuffleBtn" class="music-btn" disabled title="Shuffle Playlist">üîÄ</button>
            <input type="range" id="volumeControl" class="volume-slider" min="0" max="100" value="50">
            <div id="trackInfo" class="track-info">
                <div id="currentTrack" class="track-current">Loading YouTube Music...</div>
                <div id="nextTrack" class="track-next">Preparing playlist...</div>
            </div>
            <div id="musicExtraInfo" class="extra-info">Tip: Tab to skip ‚Ä¢ M to play/pause</div>
        </div>
        
        <!-- In-Game Inhibitor Menu -->
        <div id="ingameInhibitorMenu" class="ingame-inhibitor-menu">
            <h3>üíä Quick Inhibitors</h3>
            <div id="ingameInhibitorList">
                <!-- Populated by JavaScript -->
            </div>
            <div style="margin-top: 10px; font-size: 0.7rem; color: #888;">
                Press 'I' to toggle ‚Ä¢ Click to select/deselect
            </div>
        </div>
        
        <!-- HUD Toggle Button -->
        <div id="hudToggleBtn" style="position: absolute; bottom: 70px; right: 10px; left: auto; z-index: 150; cursor: pointer;">
            <div style="background: rgba(0, 0, 0, 0.8); border: 2px solid #00f0ff; border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; font-size: 20px; transition: all 0.3s; color: #00f0ff;" 
                 id="hudToggleIcon" title="Toggle HUD Visibility">
                üëÅÔ∏è
            </div>
        </div>
    </div>

    <script>
        // Supabase Init
        const { createClient } = supabase;
        const supabaseClient = createClient('https://imqfnxtornlvglwvkspi.supabase.co', 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImltcWZueHRvcm5sdmdsd3Zrc3BpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjMxMzQyNjksImV4cCI6MjA3ODcxMDI2OX0.Is7G7NCKxTQDoefyitkfhREXAR8m8cBBTjohRiBKMs4');

        // Game Configuration
        const GAME_CONFIG = {
            CANVAS_WIDTH: 1200,
            CANVAS_HEIGHT: 800,
            YOUTUBE_PLAYLIST_ID: 'PLHCvPuSnHYvy5mdrN4PtjCUGE69Rq7DLJ',
            
            INHIBITORS: [
                {
                    id: 'mushies',
                    name: 'MUSHIES',
                    hue: 280,
                    desc: 'Wobble movement + rainbow trails + psychedelic visuals',
                    effects: { wobble: 0.3, rainbow: true, glow: 0.4 },
                    stackable: true
                },
                {
                    id: 'lps',
                    name: 'LPS',
                    hue: 20,
                    desc: 'Damage boost + screen distortion + aggression',
                    effects: { damage: 1.4, glow: 0.5, speed: 0.9 },
                    stackable: true
                },
                {
                    id: 'neon',
                    name: 'NEON POP',
                    hue: 170,
                    desc: 'Speed surge + electric trails + bright flashes',
                    effects: { speed: 1.25, electric: true, glow: 0.8 },
                    stackable: true
                },
                {
                    id: 'sludge',
                    name: 'SLUDGE',
                    hue: 90,
                    desc: 'Tank mode: slower but tougher + toxic trails',
                    effects: { speed: 0.9, damage: 1.2, toxic: true },
                    stackable: true
                },
                {
                    id: 'glitch',
                    name: 'GLITCH COLA',
                    hue: 200,
                    desc: 'Projectiles split + reality tears + glitch effects',
                    effects: { split: true, glitchy: true, glow: 0.6 },
                    stackable: false
                },
                {
                    id: 'pixel',
                    name: 'PIXEL ACID',
                    hue: 310,
                    desc: 'Retro mode + 8-bit trails + sharp angles',
                    effects: { pixelated: true, glow: 0.7, speed: 1.1 },
                    stackable: false
                },
                {
                    id: 'vapor',
                    name: 'VAPOR WAVE',
                    hue: 140,
                    desc: 'Aesthetic overload + ghost tail DPS boost',
                    effects: { vaporwave: true, tailBoost: 0.4, glow: 0.9 },
                    stackable: false
                },
                {
                    id: 'hyper',
                    name: 'HYPER BEAM',
                    hue: 10,
                    desc: 'Charge shots + laser beams + screen shake',
                    effects: { beam: true, shake: true, glow: 0.8, damage: 1.8 },
                    stackable: false
                },
                {
                    id: 'friends',
                    name: 'FRIENDS',
                    hue: 60,
                    desc: 'Spawn friendly AI bots that help you fight',
                    effects: { friendlyBots: 1 },
                    stackable: true
                },
                {
                    id: 'ghost',
                    name: 'GHOST MODE',
                    hue: 240,
                    desc: 'Phase through enemies briefly after taking damage',
                    effects: { ghostMode: true, glow: 0.3 },
                    stackable: false
                },
                {
                    id: 'berserker',
                    name: 'BERSERKER',
                    hue: 0,
                    desc: 'Damage and speed increase when health is low',
                    effects: { berserker: true, fireRate: 1.3 },
                    stackable: false
                },
                {
                    id: 'shield',
                    name: 'ENERGY SHIELD',
                    hue: 120,
                    desc: 'Absorb damage with regenerating energy shield',
                    effects: { shield: 50 },
                    stackable: true
                },
                {
                    id: 'magnet',
                    name: 'MAGNET FIELD',
                    hue: 300,
                    desc: 'Attract enemy bullets and redirect them',
                    effects: { magnetField: true, glow: 0.5 },
                    stackable: false
                },
                {
                    id: 'time',
                    name: 'TIME WARP',
                    hue: 180,
                    desc: 'Slow down time when critically injured',
                    effects: { timeWarp: true },
                    stackable: false
                },
                {
                    id: 'regen',
                    name: 'REGENERATOR',
                    hue: 80,
                    desc: 'Slowly regenerate health over time',
                    effects: { regen: 1 },
                    stackable: true
                },
                {
                    id: 'multishot',
                    name: 'MULTI-SHOT',
                    hue: 330,
                    desc: 'Fire additional projectiles in spread pattern',
                    effects: { multishot: 2, fireRate: 0.8 },
                    stackable: true
                },
                {
                    id: 'bouncer',
                    name: 'BOUNCER',
                    hue: 45,
                    desc: 'Bullets bounce more and ricochet wildly',
                    effects: { extraBounces: 2, glow: 0.4 },
                    stackable: true
                },
                {
                    id: 'laser',
                    name: 'LASER FOCUS',
                    hue: 15,
                    desc: 'Continuous beam weapon + piercing damage',
                    effects: { laserBeam: true, piercing: true, glow: 0.8 },
                    stackable: false
                },
                {
                    id: 'swarm',
                    name: 'SWARM MODE',
                    hue: 35,
                    desc: 'Fire rate boost + smaller bullets + chaos',
                    effects: { fireRate: 2.0, bulletSize: 0.7, chaos: true },
                    stackable: true
                },
                {
                    id: 'titan',
                    name: 'TITAN FORM',
                    hue: 260,
                    desc: 'Larger ship + more HP + heavy weapons',
                    effects: { shipSize: 1.5, maxHp: 1.5, damage: 1.6, speed: 0.8 },
                    stackable: false
                },
                {
                    id: 'phase',
                    name: 'PHASE SHIFT',
                    hue: 190,
                    desc: 'Teleport through walls + dimensional effects',
                    effects: { phaseShift: true, glow: 0.6, electric: true },
                    stackable: false
                },
                {
                    id: 'vampire',
                    name: 'VAMPIRE',
                    hue: 340,
                    desc: 'Heal when killing enemies + blood effects',
                    effects: { vampire: 0.3, glow: 0.5 },
                    stackable: true
                },
                {
                    id: 'nova',
                    name: 'NOVA BURST',
                    hue: 270,
                    desc: 'Periodic shockwave explosions around ship',
                    effects: { novaBurst: true, glow: 0.7 },
                    stackable: false
                },
                {
                    id: 'mirror',
                    name: 'MIRROR SELF',
                    hue: 220,
                    desc: 'Create phantom copies that mimic your actions',
                    effects: { mirrorCopies: 1, glow: 0.4 },
                    stackable: true
                },
                {
                    id: 'vortex',
                    name: 'VORTEX',
                    hue: 160,
                    desc: 'Pull enemies toward you + spinning attacks',
                    effects: { vortex: true, tailBoost: 0.3, glow: 0.6 },
                    stackable: false
                },
                {
                    id: 'acidtrip',
                    name: 'ACID TRIP',
                    hue: 110,
                    desc: 'Reality melts + enemies move unpredictably + kaleidoscope',
                    effects: { acidTrip: true, rainbow: true, chaos: true, glow: 0.9 },
                    stackable: false
                },
                {
                    id: 'overdrive',
                    name: 'OVERDRIVE',
                    hue: 355,
                    desc: 'Everything faster + screen streaks + adrenaline mode',
                    effects: { speed: 1.4, fireRate: 1.5, glow: 0.8, electric: true },
                    stackable: false
                },
                {
                    id: 'zen',
                    name: 'ZEN MODE',
                    hue: 200,
                    desc: 'Time dilation + perfect accuracy + calm visuals',
                    effects: { zen: true, accuracy: 1.5, glow: 0.3 },
                    stackable: false
                },
                {
                    id: 'chaos',
                    name: 'CHAOS ENGINE',
                    hue: 25,
                    desc: 'Random effects every few seconds + wild visuals',
                    effects: { chaosEngine: true, glow: 0.7, random: true },
                    stackable: false
                },
                {
                    id: 'sniper',
                    name: 'SNIPER MODE',
                    hue: 250,
                    desc: 'Long range + high damage + slow firing + zoom effect',
                    effects: { sniperMode: true, damage: 2.2, fireRate: 0.4, range: 2.0 },
                    stackable: false
                },
                {
                    id: 'spiral',
                    name: 'SPIRAL SHOT',
                    hue: 135,
                    desc: 'Bullets curve in spirals + creates vortex patterns',
                    effects: { spiralShot: true, glow: 0.6 },
                    stackable: false
                },
                {
                    id: 'tank',
                    name: 'TANK MODE',
                    hue: 30,
                    desc: 'Massive HP boost + explosive ammo + heavy armor',
                    effects: { maxHp: 2.5, damage: 1.8, speed: 0.6, explosive: true },
                    stackable: false
                },
                {
                    id: 'blink',
                    name: 'BLINK',
                    hue: 210,
                    desc: 'Teleport to mouse position + invulnerability frames',
                    effects: { blink: true, glow: 0.5 },
                    stackable: false
                }
            ],
            
            DIFFICULTIES: {
                easy: {
                    name: 'Easy',
                    enemyHpMult: 0.4,
                    enemyDmgMult: 0.7,
                    spawnRateMult: 0.7,
                    enemyCountMult: 0.7,
                    upgradeSpeedMult: 1.5,
                    inhibitorLimit: Infinity
                },
                normal: {
                    name: 'Normal',
                    enemyHpMult: 0.8,
                    enemyDmgMult: 1.0,
                    spawnRateMult: 1.2,
                    enemyCountMult: 1.5,
                    upgradeSpeedMult: 1.0,
                    inhibitorLimit: 5
                },
                hard: {
                    name: 'Hard',
                    enemyHpMult: 1.2,
                    enemyDmgMult: 1.4,
                    spawnRateMult: 1.8,
                    enemyCountMult: 2.5,
                    upgradeSpeedMult: 0.6,
                    inhibitorLimit: 3
                }
            }
        };

        const powerUpTypes = {
            health: { color: '#00ff00', symbol: 'H', apply: (player) => { player.hp = Math.min(player.maxHp, player.hp + 25); showToast('+25 Health', 'success'); } },
            shield: { color: '#00ffff', symbol: 'S', apply: (player) => { if(player.shield) player.shield = Math.min(player.maxShield, player.shield + 25); else player.shield = 25; if(!player.maxShield || player.maxShield < player.shield) player.maxShield = player.shield; showToast('+25 Shield', 'info'); } },
            shield: { color: '#00ffff', symbol: 'S', apply: (player) => { if(player.shield) player.shield = Math.min(player.maxShield, player.shield + 25); else player.shield = 25; if(!player.maxShield || player.maxShield < player.shield) player.maxShield = player.shield; showToast('+25 Shield', 'info'); } },
            weapon: { color: '#ff00ff', symbol: 'W', apply: (player) => { player.fireRate *= 1.5; showToast('Fire Rate Up!', 'warning'); setTimeout(() => { player.fireRate /= 1.5; showToast('Fire Rate Restored.', 'info'); }, 5000); } },
            // New power-up: Ally Respawn
            ally_respawn: {
                color: '#8844ff', // Purple color
                symbol: 'A', // 'A' for Ally
                apply: (player) => {
                    const activeAllies = friendlyBots.filter(bot => bot.type === 'ally');
                    if (activeAllies.length < allyConfig.count) {
                        // Find a missing allyIndex
                        let missingIndex = -1;
                        for (let i = 0; i < allyConfig.count; i++) {
                            if (!activeAllies.some(ally => ally.allyIndex === i)) {
                                missingIndex = i;
                                break;
                            }
                        }
                        if (missingIndex !== -1) {
                            spawnAlly(missingIndex);
                            showToast('Ally respawned!', 'info');
                        } else {
                            // This shouldn't happen if activeAllies.length < allyConfig.count
                            showToast('No ally to respawn!', 'warning');
                        }
                    } else {
                        showToast('All allies already active!', 'warning');
                    }
                }
            }
        };
		
        // Game State
        let gameState = 'menu';
        let gameStartTime = 0;
        let leaderboardSort = { by: 'score', order: 'desc' };
        let flashingEffectsDisabled = false;
        let selectedDifficulty = 'normal';
        let selectedInhibitors = [];
        let playerName = 'Player';
        let shootingMode = 'hold'; // 'hold' or 'click'
        let fpsLimit = 0; // Default to Unlimited
        let shipCustomization = {
            shape: 'triangle',
            bodyColor: '#ffffff',
            accentColor: '#00f0ff'
        };
        
        let ammoCustomization = {
            type: 'standard',
            color: '#ff4444',
            size: 'medium'
        };
        
        let tailCustomization = {
            width: 3,
            glow: 50,
            color: '#00f0ff'
        };
        
            let allyConfig = {
            count: 2,
            behavior: 'balanced', // defensive, balanced, aggressive
            shapes: ['triangle', 'diamond', 'arrow', 'star'],
            bodyColors: ['#00ff88', '#ff8800', '#8800ff', '#ff0088'],
            accentColors: ['#00ffff', '#ffff00', '#ff00ff', '#00ff00'],
            titleColors: ['#ff4444', '#ff4444', '#ff4444', '#ff4444'], // Label colors for each ally
            sizes: [14, 12, 16, 13], // Different sizes for variety
            aimMode: 'auto', // auto (predictive), follow (cursor), quadrant
            independentAI: false, // Whether bots have their own AI tactics
            difficultyMultiplier: 1.0, // Bot performance multiplier when independent
            // Ally tail settings
            tailEnabled: [true, true, true, true], // Per-ally tail enable (visible by default)
            tailColors: ['#00ffff', '#ffff00', '#ff00ff', '#00ff00'], // Per-ally tail colors
            tailWidths: [3, 3, 3, 3], // Per-ally tail widths (slightly thicker for visibility)
            tailGlows: [45, 45, 45, 45] // Per-ally tail glow intensity (brighter)
        };
        
        const ammoTypes = ['standard', 'piercing', 'explosive', 'spread'];
        let currentAmmoTypeIndex = 0;
        
        // Cursor/crosshair settings - default enabled
        let cursorSettings = {
            enabled: true,
            type: 'cross', // cross, dot, circle, target
            size: 20,
            color: '#00ff00',
            opacity: 0.8
        };
        
        // Mouse sensitivity
        let mouseSensitivity = 1.0;
        
        // Secondary weapon settings
        let secondaryHoldMode = false;
        
            // Ally name display
        let showAllyNames = true;
        
        // Ally title colors per ally (for labels)
        
        // HUD visibility
        let hudVisible = true;
        let hudAutoHide = false; // Auto-hide disabled by default; can be enabled in Settings
        let hudAutoHideTimer = 0;
        let hudLevelShowTimer = 0;
        let userToggledHud = false; // Track if user manually toggled
            
            // Global ally multipliers
            let allyMultipliers = {
                hp: 1.0,
                damage: 1.0,
                speed: 1.0
            };
        
        let friendlyBots = [];
        let inhibitorStacks = new Map(); // Track how many times each inhibitor is selected
        
        let graphicsSettings = {
            showGrid: true, // Enable by default
            particleQuality: 'high', // High quality by default
            screenShake: true, // Enable by default
            visualEffects: true // Enable by default
        };
        
        // Settings - Default to high quality values
        let musicReactivity = 50;
        let playerGlowIntensity = 50; // New setting for player glow that responds to music
                    let visualSettings = {
                        colorPulse: true, // Enable by default
                        backgroundReact: true, // Enable by default
                        trippyEffects: true, // Enable by default
                        tailWarning: true,
                        backgroundAnimation: true, // Enable by default
                        backgroundMovement: true // Enable by default
                    };
        
                    // Player Learning State (Adaptive AI)
                    let playerLearningState = {
                        playerAggression: 0.5, // 0 = passive, 1 = aggressive
                        playerSpeed: 0.5,      // 0 = slow, 1 = fast/boosting often
                        playerAccuracy: 0.5,   // 0 = low, 1 = high
                        playerEvasiveness: 0.5, // 0 = direct, 1 = dodging/moving
                        enemyKillCount: 0,      // Total enemies killed by player
                        playerHitCount: 0,      // Times player has been hit
                        timePlaying: 0,         // Total time player has been playing
                        adaptiveDifficultyOffset: 0 // Overall offset to difficulty based on learning
                    };
        
                    const LEARNING_STATE_KEY = 'voidDrifterLearningState';
        
                    function saveLearningState() {
                        try {
                            localStorage.setItem(LEARNING_STATE_KEY, JSON.stringify(playerLearningState));
                            console.log('Player learning state saved.');
                        } catch (e) {
                            console.warn('Failed to save player learning state:', e);
                        }
                    }
        
                    function loadLearningState() {
                        try {
                            const savedState = localStorage.getItem(LEARNING_STATE_KEY);
                            if (savedState) {
                                const parsedState = JSON.parse(savedState);
                                // Merge with defaults to ensure new properties are added
                                Object.assign(playerLearningState, parsedState);
                                console.log('Player learning state loaded.', playerLearningState);
                            } else {
                                console.log('No saved learning state found. Using defaults.');
                            }
                        } catch (e) {
                            console.warn('Failed to load player learning state, using defaults:', e);
                            // Reset to default on error
                            playerLearningState = {
                                playerAggression: 0.5,
                                playerSpeed: 0.5,
                                playerAccuracy: 0.5,
                                playerEvasiveness: 0.5,
                                enemyKillCount: 0,
                                playerHitCount: 0,
                                timePlaying: 0,
                                adaptiveDifficultyOffset: 0
                            };
                        }
                    }
        // Game Objects
        let player = null;
        let bullets = [];
        let enemies = [];
        let particles = [];
        let powerUps = [];
        let tailSegments = [];
        let secondaryCharging = false;
        let secondaryChargeTime = 0;
        let maxSecondaryCharge = 2.0; // 2 second max charge

        // Game Stats
        let gameStats = {
            score: 0,
            playerScore: 0,
            allyScore: 0,
            wave: 1,
            level: 1,
            enemiesKilled: 0,
            playerHitCount: 0, // Track how many times player is hit
            hp: 100,
            maxHp: 100,
            boostFuel: 100,
            shotsFired: 0,
            shotsHit: 0,
            deaths: 0
        };

        // Input
        let keys = new Set();
        let mouse = { x: 400, y: 300, down: false, rightDown: false };

        // Timers
        let enemySpawnTimer = 0;
        let lastTime = 0;
        let gameTime = 0;
        let lastSaveTime = 0; // For periodic saving of learning state
        const SAVE_INTERVAL = 60; // Save learning state every 60 seconds
        let tailLength = 10; // Start with short tail
        let tailGrowthRate = 0.5; // Segments per second
        let maxTailLength = 150;
        let tailWarningShown = false;
        let clickShootCooldown = 0;
        
        // Simple frame counter for occasional tasks
        let frameCount = 0;
        let targetFrameTime = 0; // Unlimited FPS by default
        let lastRenderTime = 0;
        

        // Audio
        let audioContext = null;
        let musicVolume = 50;
        let sfxVolume = 70;
        let youtubePlayer = null;
        let youtubeReady = false;
        
        // Music analysis
        let musicAnalyser = null;
        let musicDataArray = null;
        let musicFrequencyData = null;
        let currentMusicIntensity = 0;

        // Canvas
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Utility Functions
        const Utils = {
            clamp: (v, min, max) => Math.max(min, Math.min(max, v)),
            lerp: (a, b, t) => a + (b - a) * t,
            rand: (a = 1, b = null) => b == null ? Math.random() * a : a + Math.random() * (b - a),
            randInt: (a, b) => Math.floor(Utils.rand(a, b + 1)),
            angleTo: (a, b) => Math.atan2(b.y - a.y, b.x - a.x),
            distance: (a, b) => Math.hypot(b.x - a.x, b.y - a.y),
            rainbow: (time, speed = 1) => {
                const hue = (time * speed) % 360;
                return `hsl(${hue}, 100%, 60%)`;
            },
            distPointToSegment: (p, a, b) => {
                const abx = b.x - a.x, aby = b.y - a.y;
                const apx = p.x - a.x, apy = p.y - a.y;
                const ab2 = abx*abx + aby*aby;
                if (ab2 === 0) return Math.hypot(apx, apy);
                const t = Math.max(0, Math.min(1, (apx*abx + apy*aby) / ab2));
                const cx = a.x + t*abx, cy = a.y + t*aby;
                return Math.hypot(p.x - cx, p.y - cy);
            }
        };

        // Screen Shake
        let screenShake = { x: 0, y: 0, intensity: 0, duration: 0 };

        function addScreenShake(intensity, duration) {
            if (!graphicsSettings.screenShake) return;
            screenShake.intensity = Math.max(screenShake.intensity, intensity);
            screenShake.duration = Math.max(screenShake.duration, duration);
        }

        function updateScreenShake(deltaTime) {
            if (screenShake.duration > 0) {
                screenShake.duration -= deltaTime;
                if (screenShake.duration <= 0) {
                    screenShake.x = 0;
                    screenShake.y = 0;
                    screenShake.intensity = 0;
                } else {
                    screenShake.x = (Math.random() - 0.5) * screenShake.intensity;
                    screenShake.y = (Math.random() - 0.5) * screenShake.intensity;
                    screenShake.intensity *= 0.95;
                }
            }
        }

        // Music Analysis
        function getMusicIntensity() {
            if (!musicAnalyser || !musicDataArray || !youtubeReady) {
                // Simple beat simulation when no music analysis available
                const elapsed = (performance.now()) / 1000;
                const beatLength = 60 / 120; // 120 BPM
                const phase = (elapsed % beatLength) / beatLength;
                return Math.max(0, Math.cos(phase * Math.PI * 2) * 0.3 + 0.2) * (musicReactivity / 100);
            }
            
            // YouTube music analysis (when available)
            musicAnalyser.getByteFrequencyData(musicDataArray);
            
            let sum = 0;
            const bassRange = Math.floor(musicDataArray.length * 0.1);
            const midRange = Math.floor(musicDataArray.length * 0.4);
            
            for (let i = 0; i < bassRange; i++) {
                sum += musicDataArray[i] * 2;
            }
            for (let i = bassRange; i < midRange; i++) {
                sum += musicDataArray[i] * 1.5;
            }
            for (let i = midRange; i < musicDataArray.length; i++) {
                sum += musicDataArray[i];
            }
            
            const intensity = (sum / (musicDataArray.length * 255)) * (musicReactivity / 100);
            currentMusicIntensity = Utils.lerp(currentMusicIntensity, intensity, 0.1);
            return Math.min(1, currentMusicIntensity);
        }
        
        // Update background stars based on music
        function updateBackgroundStars(musicIntensity) {
            if (!visualSettings.backgroundAnimation) return;
            
            const body = document.body;
            const baseSpeed = visualSettings.backgroundMovement ? 60 : 999999; // Disable movement if setting is off
            const musicSpeedMultiplier = visualSettings.backgroundReact ? (1 + musicIntensity * 2) : 1;
            const currentSpeed = visualSettings.backgroundMovement ? Math.max(10, baseSpeed / musicSpeedMultiplier) : 999999; // Prevent too fast
            
            // Update star brightness and opacity based on music intensity
            const brightness = 1 + (musicIntensity * 0.8);
            const opacityStart = 0.8 + (musicIntensity * 0.3);
            const opacityMid = 1 + (musicIntensity * 0.4);
            const opacityPeak = Math.min(1.5, 1.2 + (musicIntensity * 0.8));
            const opacityEnd = 0.6 + (musicIntensity * 0.2);
            
            // Color shift based on music (subtle hue rotation)
            const hueShift = visualSettings.colorPulse ? (gameTime * 20 + musicIntensity * 60) % 360 : 0;
            
            // Apply CSS variables for dynamic star animation
            body.style.setProperty('--star-speed', `${currentSpeed}s`);
            body.style.setProperty('--star-brightness', brightness);
            body.style.setProperty('--star-opacity-start', opacityStart);
            body.style.setProperty('--star-opacity-mid', opacityMid);
            body.style.setProperty('--star-opacity-peak', opacityPeak);
            body.style.setProperty('--star-opacity-end', opacityEnd);
            body.style.setProperty('--star-hue', `${hueShift}deg`);
        }
        
        function setupMusicAnalysis() {
            if (!youtubePlayer || !audioContext) return;
            
            try {
                // This is tricky with YouTube - we'll use a fallback approach
                // For now, we'll simulate music analysis with enhanced beat detection
                console.log('Music analysis setup attempted');
            } catch (e) {
                console.warn('Could not setup music analysis:', e);
            }
        }

        // SFX System
        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                console.warn('Audio context failed');
            }
        }

        function playSFX(type) {
            if (!audioContext || sfxVolume === 0) return;
            
            try {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                
                switch (type) {
                    case 'hit':
                        osc.frequency.setValueAtTime(800, audioContext.currentTime);
                        osc.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.1);
                        gain.gain.setValueAtTime(0.3 * sfxVolume / 100, audioContext.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
                        break;
                    case 'explosion':
                        // Removed noisy explosion sound - use clean oscillator instead
                        osc.frequency.setValueAtTime(300, audioContext.currentTime);
                        osc.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.3);
                        gain.gain.setValueAtTime(0.4 * sfxVolume / 100, audioContext.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);
                        break;
                    case 'pickup':
                        osc.frequency.value = 600;
                        gain.gain.setValueAtTime(0.2 * sfxVolume / 100, audioContext.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.2);
                        break;
                    case 'charge':
                        osc.frequency.setValueAtTime(200, audioContext.currentTime);
                        osc.frequency.linearRampToValueAtTime(400, audioContext.currentTime + 0.1);
                        gain.gain.setValueAtTime(0.1 * sfxVolume / 100, audioContext.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
                        break;
                }
                
                osc.connect(gain);
                gain.connect(audioContext.destination);
                osc.start();
                osc.stop(audioContext.currentTime + 0.3);
            } catch (e) {
                // Silent fail
            }
        }

        // YouTube Music System (minimal)
        let musicPlayerHidden = false;
        let musicControlsMoved = false; // Track if user dragged the music controls
        
        
        function loadYouTubeAPI() {
            const current = document.getElementById('currentTrack');
            const next = document.getElementById('nextTrack');
            if (current) current.textContent = 'Initializing YouTube...';
            if (next) next.textContent = 'TV Trip Mix Ready';
            
            if (window.YT && window.YT.Player) {
                initYouTubePlayer();
                return;
            }
            
            window.onYouTubeIframeAPIReady = initYouTubePlayer;
            const script = document.createElement('script');
            script.src = 'https://www.youtube.com/iframe_api';
            script.async = true;
            document.head.appendChild(script);
        }
        
        
        
        function enableMusicControls() {
            const buttons = ['playPauseBtn', 'prevBtn', 'nextBtn', 'shuffleBtn'];
            buttons.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) {
                    btn.disabled = false;
                    btn.style.opacity = '1';
                }
            });
        }
        
        
        
        

        function initYouTubePlayer() {
            try {
                // Ensure a hidden player container exists
                let playerDiv = document.getElementById('youtube-player');
                if (!playerDiv) {
                    playerDiv = document.createElement('div');
                    playerDiv.id = 'youtube-player';
                    playerDiv.style.cssText = `
                        position: fixed;
                        top: -1000px;
                        left: -1000px;
                        width: 1px;
                        height: 1px;
                        pointer-events: none;
                        opacity: 0;
                        z-index: -1000;
                    `;
                    document.body.appendChild(playerDiv);
                }

                youtubePlayer = new YT.Player('youtube-player', {
                    height: '1',
                    width: '1',
                    playerVars: {
                        listType: 'playlist',
                        list: GAME_CONFIG.YOUTUBE_PLAYLIST_ID,
                        autoplay: 0,
                        controls: 0,
                        enablejsapi: 1,
                        modestbranding: 1,
                        playsinline: 1,
                        rel: 0
                    },
                    events: {
                        onReady: () => {
                            youtubeReady = true;
                            try { youtubePlayer.setVolume(musicVolume); } catch (e) {}
                            const current = document.getElementById('currentTrack');
                            const next = document.getElementById('nextTrack');
                            if (current) current.textContent = '‚ô™ TV Trip Mix Ready';
                            if (next) next.textContent = 'Press ‚ñ∂ to start';
                            enableMusicControls();
                        },
                        onStateChange: (event) => {
                            const playBtn = document.getElementById('playPauseBtn');
                            if (playBtn) playBtn.textContent = event.data === YT.PlayerState.PLAYING ? '‚è∏' : '‚ñ∂';
                            if (event.data === YT.PlayerState.PLAYING) updateTrackInfo();
                        },
                        onError: (event) => {
                            // Skip unembeddable or blocked videos
                            if (event.data === 101 || event.data === 150) {
                                try { youtubePlayer.nextVideo(); } catch (e) {}
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('YouTube player creation error:', error);
            }
        }
        
        function getPlayerStateName(state) {
            const states = {
                [-1]: 'UNSTARTED',
                [0]: 'ENDED',
                [1]: 'PLAYING',
                [2]: 'PAUSED',
                [3]: 'BUFFERING',
                [5]: 'CUED'
            };
            return states[state] || 'UNKNOWN';
        }
        
        function updateTrackInfo() {
            const currentTrackEl = document.getElementById('currentTrack');
            const nextTrackEl = document.getElementById('nextTrack');
            
            if (!currentTrackEl || !nextTrackEl) return; // Safety check
            
            if (!youtubePlayer || !youtubeReady || youtubePlayer.getPlayerState() === -1) { // -1 means unstarted
                currentTrackEl.textContent = '‚ô™ Music Player (Not Started)';
                nextTrackEl.textContent = 'Press ‚ñ∂ to begin';
                return;
            }

            try {
                // Attempt to get video data, but be prepared for it to fail due to CORS
                const videoData = youtubePlayer.getVideoData();
                
                if (videoData && videoData.title && videoData.title !== '') {
                    // Clean up title (if successful)
                    let title = videoData.title;
                    title = title.replace(/\s*\(Official.*?\)/gi, '');
                    title = title.replace(/\s*\[Official.*?\]/gi, '');
                    title = title.replace(/\s*-\s*YouTube$/, '');
                    
                    currentTrackEl.textContent = `‚ô™ ${title}`;
                    nextTrackEl.textContent = 'TV Trip Mix Active';
                } else {
                    // Fallback for when getVideoData fails or returns empty title (due to CORS)
                    currentTrackEl.textContent = '‚ô™ TV Trip Mix (Playing)';
                    nextTrackEl.textContent = 'Next track pending...';
                }
            } catch (e) {
                console.warn('Error accessing YouTube video data (likely CORS/security):', e);
                // More robust fallback for severe errors
                currentTrackEl.textContent = '‚ô™ TV Trip Mix (Playing)';
                nextTrackEl.textContent = 'Track info unavailable';
            }
        }

        // Player System
        function resetPlayer() {
            player = {
                x: GAME_CONFIG.CANVAS_WIDTH / 2,
                y: GAME_CONFIG.CANVAS_HEIGHT / 2,
                vx: 0, vy: 0,
                angle: 0,
                radius: 12,
                hp: 100,
                maxHp: 100,
                speed: 250, // 25% faster movement
                fireRate: 8, // Faster than before but not extreme
                damage: 1,
                invulnerable: 2,
                fireTimer: 0,
                boostFuel: 100,
                maxBoostFuel: 100,
                weapon: 1,
                shield: 0,
                maxShield: 0
            };
            
            tailSegments = [];
            friendlyBots = [];
            gameStats.hp = 100;
            gameStats.maxHp = 100;
            gameStats.boostFuel = 100;
            secondaryCharging = false;
            secondaryChargeTime = 0;

            // Reset learning state metrics for the new game session
            playerLearningState.enemyKillCount = 0;
            playerLearningState.playerHitCount = 0;
            playerLearningState.lastPlayerHitCount = 0;
            playerLearningState.lastHitTime = 0;
        }

        function calculateModifiers() {
            let mods = {
                speed: 1,
                damage: 1,
                fireRate: 1,
                effects: {
                    wobble: 0,
                    glow: 0,
                    friendly: 0.1,
                    hostile: 0.1,
                    tailBoost: 0,
                    friendlyBots: 0,
                    shield: 0,
                    regen: 0
                },
                tags: {
                    rainbow: false,
                    electric: false,
                    toxic: false,
                    beam: false,
                    split: false,
                    glitchy: false,
                    pixelated: false,
                    vaporwave: false,
                    shake: false,
                    ghostMode: false,
                    berserker: false,
                    magnetField: false,
                    timeWarp: false
                }
            };

            // Apply stacked inhibitors with difficulty limits
            const difficulty = GAME_CONFIG.DIFFICULTIES[selectedDifficulty];
            const maxInhibitors = difficulty.inhibitorLimit;
            let appliedCount = 0;
            
            inhibitorStacks.forEach((count, inhibitorId) => {
                if (appliedCount >= maxInhibitors && maxInhibitors !== Infinity) return;
                
                const inhibitor = GAME_CONFIG.INHIBITORS.find(inh => inh.id === inhibitorId);
                if (inhibitor && inhibitor.effects) {
                    // Apply multipliers (stack multiplicatively)
                    for (let i = 0; i < count; i++) {
                        if (inhibitor.effects.speed) mods.speed *= inhibitor.effects.speed;
                        if (inhibitor.effects.damage) mods.damage *= inhibitor.effects.damage;
                        if (inhibitor.effects.fireRate) mods.fireRate *= inhibitor.effects.fireRate;
                    }
                    
                    // Apply effects (stack additively)
                    Object.keys(inhibitor.effects).forEach(key => {
                        if (mods.effects.hasOwnProperty(key)) {
                            mods.effects[key] += inhibitor.effects[key] * count;
                        } else if (mods.tags.hasOwnProperty(key)) {
                            mods.tags[key] = true;
                        }
                    });
                    
                    appliedCount++;
                }
            });

            return mods;
        }

        function updateLearningMetrics(deltaTime) {
            // Player Aggression: Based on firing frequency and proximity to enemies
            // Decay previous aggression value
            playerLearningState.playerAggression = Utils.lerp(playerLearningState.playerAggression, 0.5, 0.001 * deltaTime); // Drift to neutral over time

            if (mouse.down || secondaryCharging) { // Player is actively trying to shoot
                playerLearningState.playerAggression = Utils.lerp(playerLearningState.playerAggression, 0.7, 0.01 * deltaTime);
            }
            if (player.fireTimer <= 0 && (mouse.down || secondaryCharging)) { // Actual shot
                playerLearningState.playerAggression = Utils.lerp(playerLearningState.playerAggression, 0.8, 0.02 * deltaTime);
            }

            let closestEnemyDist = Infinity;
            enemies.forEach(enemy => {
                closestEnemyDist = Math.min(closestEnemyDist, Utils.distance(player, enemy));
            });

            if (closestEnemyDist < player.radius * 10) { // Close to enemies
                playerLearningState.playerAggression = Utils.lerp(playerLearningState.playerAggression, 0.75, 0.005 * deltaTime);
            } else if (closestEnemyDist > GAME_CONFIG.CANVAS_WIDTH / 2) { // Far from enemies
                playerLearningState.playerAggression = Utils.lerp(playerLearningState.playerAggression, 0.3, 0.001 * deltaTime);
            }

            // Player Speed/Movement: Based on boosting and overall velocity
            playerLearningState.playerSpeed = Utils.lerp(playerLearningState.playerSpeed, 0.5, 0.001 * deltaTime); // Drift to neutral

            const currentSpeedMag = Math.hypot(player.vx, player.vy);
            const maxPlayerSpeed = player.speed * 1.8; // Max speed with boost
            const speedRatio = Utils.clamp(currentSpeedMag / maxPlayerSpeed, 0, 1);
            playerLearningState.playerSpeed = Utils.lerp(playerLearningState.playerSpeed, speedRatio, 0.01 * deltaTime);

            if ((keys.has('shift') || keys.has(' ')) && player.boostFuel > 0) { // Boosting
                playerLearningState.playerSpeed = Utils.lerp(playerLearningState.playerSpeed, 0.9, 0.02 * deltaTime);
            }

            // Player Accuracy: Tracked via gameStats.shotsHit / gameStats.shotsFired. Updated less frequently.
            if (gameStats.shotsFired > 10) { // Only calculate once enough shots are fired
                const currentAccuracy = gameStats.shotsHit / gameStats.shotsFired;
                playerLearningState.playerAccuracy = Utils.lerp(playerLearningState.playerAccuracy, currentAccuracy, 0.005 * deltaTime);
            }

            // Player Evasiveness: Based on playerHitCount and enemy density (inverse of hits/threat)
            // This one is trickier. For now, we'll use an inverse relationship with hit count.
            // Decay towards neutral
            playerLearningState.playerEvasiveness = Utils.lerp(playerLearningState.playerEvasiveness, 0.5, 0.0005 * deltaTime);

            // If player has been hit, decreases evasiveness slightly, if not hit for a while, increases
            if (gameStats.playerHitCount > playerLearningState.lastPlayerHitCount) {
                playerLearningState.playerEvasiveness = Utils.lerp(playerLearningState.playerEvasiveness, 0.1, 0.05 * deltaTime); // Got hit, so less evasive
            } else if (gameTime - playerLearningState.lastHitTime > 5) { // If no hit for 5 seconds, slightly more evasive
                 playerLearningState.playerEvasiveness = Utils.lerp(playerLearningState.playerEvasiveness, 0.9, 0.001 * deltaTime);
            }
            playerLearningState.lastPlayerHitCount = gameStats.playerHitCount;
            if (gameStats.playerHitCount > playerLearningState.lastPlayerHitCountAtTime) {
                playerLearningState.lastHitTime = gameTime;
                playerLearningState.lastPlayerHitCountAtTime = gameStats.playerHitCount;
            }

            // Update total kill count directly
            playerLearningState.enemyKillCount = gameStats.enemiesKilled;
        }

        function updatePlayer(deltaTime) {
            updateLearningMetrics(deltaTime); // Update player learning metrics
            const mods = calculateModifiers();
            
            // Spawn allies based on configuration (main allies)
            const activeMainAllies = friendlyBots.filter(bot => bot.type === 'ally');
            const currentAllyIndices = new Set(activeMainAllies.map(bot => bot.allyIndex));
            
            for (let i = 0; i < allyConfig.count; i++) {
                if (!currentAllyIndices.has(i)) {
                    spawnAlly(i); // Spawn missing ally with its correct index
                }
            }
            
            // Spawn friendly bots from inhibitors (smaller support bots)
            const supportBotsNeeded = Math.floor(mods.effects.friendlyBots) * 3; // 3 per stack
            let currentSupportBots = friendlyBots.filter(bot => bot.type === 'support').length;
            while (currentSupportBots < supportBotsNeeded) {
                spawnSupportBot();
                currentSupportBots++;
            }
            
            // Update friendly bots
            updateFriendlyBots(deltaTime, mods);
            
            // Movement
            let dx = 0, dy = 0;
            if (keys.has('w') || keys.has('arrowup')) dy -= 1;
            if (keys.has('s') || keys.has('arrowdown')) dy += 1;
            if (keys.has('a') || keys.has('arrowleft')) dx -= 1;
            if (keys.has('d') || keys.has('arrowright')) dx += 1;

            const inputMag = Math.hypot(dx, dy) || 1;
            dx /= inputMag;
            dy /= inputMag;

            // Apply wobble
            if (mods.effects.wobble > 0) {
                const wobbleTime = gameTime * 3;
                dx += Math.sin(wobbleTime) * mods.effects.wobble * 0.3;
                dy += Math.cos(wobbleTime * 1.1) * mods.effects.wobble * 0.3;
            }

            let speed = player.speed * mods.speed;
            
            // Boost
            const boosting = (keys.has('shift') || keys.has(' ')) && player.boostFuel > 0;
            if (boosting) {
                speed *= 1.8;
                player.boostFuel = Math.max(0, player.boostFuel - 60 * deltaTime);
            } else {
                player.boostFuel = Math.min(player.maxBoostFuel, player.boostFuel + 40 * deltaTime);
            }

            player.vx = dx * speed;
            player.vy = dy * speed;
            
            player.x = Utils.clamp(player.x + player.vx * deltaTime, player.radius, GAME_CONFIG.CANVAS_WIDTH - player.radius);
            player.y = Utils.clamp(player.y + player.vy * deltaTime, player.radius, GAME_CONFIG.CANVAS_HEIGHT - player.radius);
            
            // Update angle with mouse sensitivity
            const targetAngle = Utils.angleTo(player, mouse);
            if (mouseSensitivity !== 1.0) {
                // Apply sensitivity by lerping between current and target angle
                const angleDiff = targetAngle - player.angle;
                // Handle angle wrapping
                const wrappedAngleDiff = Math.atan2(Math.sin(angleDiff), Math.cos(angleDiff));
                player.angle += wrappedAngleDiff * mouseSensitivity * deltaTime * 10;
            } else {
                player.angle = targetAngle;
            }

            // Update timers
            player.fireTimer = Math.max(0, player.fireTimer - deltaTime);
            player.invulnerable = Math.max(0, player.invulnerable - deltaTime);

            // Firing
            clickShootCooldown = Math.max(0, clickShootCooldown - deltaTime);
            if (shootingMode === 'hold') {
                if (mouse.down && player.fireTimer <= 0) {
                    firePrimary(mods);
                    player.fireTimer = 1 / (player.fireRate * mods.fireRate);
                }
            } else if (shootingMode === 'click') {
                // Click shooting is handled in mouse event
            }
            
            // Secondary weapon charging
            if (secondaryHoldMode) {
                // Hold mode - continuous charging while held
                if (mouse.rightDown) {
                    if (!secondaryCharging) {
                        secondaryCharging = true;
                        secondaryChargeTime = 0;
                        playSFX('charge');
                    }
                    
                    // Faster charge rate - less nerfed
                    secondaryChargeTime = Math.min(maxSecondaryCharge, secondaryChargeTime + deltaTime * 0.9);
                    
                    // More visible charge particles
                    if (Math.random() < 0.35) {
                        const angle = Utils.rand(0, Math.PI * 2);
                        const distance = Utils.rand(10, 30);
                        const chargeIntensity = secondaryChargeTime / maxSecondaryCharge;
                        
                        particles.push({
                            x: player.x + Math.cos(angle) * distance,
                            y: player.y + Math.sin(angle) * distance,
                            vx: -Math.cos(angle) * (60 + chargeIntensity * 40),
                            vy: -Math.sin(angle) * (60 + chargeIntensity * 40),
                            radius: 2 + chargeIntensity * 2,
                            color: chargeIntensity > 0.7 ? '#ff0080' : '#ffff00',
                            life: 0.8,
                            maxLife: 0.8,
                            alpha: 1
                        });
                    }
                    
                    // Add electric arcs when highly charged
                    if (secondaryChargeTime > maxSecondaryCharge * 0.6 && Math.random() < 0.2) {
                        const angle = Utils.rand(0, Math.PI * 2);
                        const distance = Utils.rand(20, 40);
                        particles.push({
                            x: player.x + Math.cos(angle) * distance,
                            y: player.y + Math.sin(angle) * distance,
                            vx: -Math.cos(angle) * 80,
                            vy: -Math.sin(angle) * 80,
                            radius: 1,
                            color: '#00ffff',
                            life: 0.3,
                            maxLife: 0.3,
                            alpha: 1
                        });
                    }
                }
            } else {
                // Tap mode - start charging on right click
                if (mouse.rightDown && !secondaryCharging) {
                    secondaryCharging = true;
                    secondaryChargeTime = 0;
                    playSFX('charge');
                }
                
                if (secondaryCharging) {
                    secondaryChargeTime = Math.min(maxSecondaryCharge, secondaryChargeTime + deltaTime);
                    
                    // Enhanced charge particles for tap mode
                    if (Math.random() < 0.3) {
                        const angle = Utils.rand(0, Math.PI * 2);
                        const distance = Utils.rand(15, 35);
                        const chargeIntensity = secondaryChargeTime / maxSecondaryCharge;
                        
                        particles.push({
                            x: player.x + Math.cos(angle) * distance,
                            y: player.y + Math.sin(angle) * distance,
                            vx: -Math.cos(angle) * (70 + chargeIntensity * 50),
                            vy: -Math.sin(angle) * (70 + chargeIntensity * 50),
                            radius: 2.5 + chargeIntensity * 1.5,
                            color: chargeIntensity > 0.8 ? '#ff0080' : '#ffff00',
                            life: 0.6,
                            maxLife: 0.6,
                            alpha: 1
                        });
                    }
                    
                    // Add sparks when fully charged
                    if (secondaryChargeTime >= maxSecondaryCharge && Math.random() < 0.4) {
                        const angle = Utils.rand(0, Math.PI * 2);
                        const distance = Utils.rand(25, 45);
                        particles.push({
                            x: player.x + Math.cos(angle) * distance,
                            y: player.y + Math.sin(angle) * distance,
                            vx: -Math.cos(angle) * 100,
                            vy: -Math.sin(angle) * 100,
                            radius: 3,
                            color: '#ffffff',
                            life: 0.4,
                            maxLife: 0.4,
                            alpha: 1
                        });
                    }
                }
            }

            // Update tail
            updateTail(deltaTime);
            
            // Apply inhibitor effects
            applyInhibitorEffects(deltaTime, mods);
            
            // Update stats display
            gameStats.hp = Math.max(0, Math.ceil(player.hp));
            gameStats.boostFuel = Math.ceil(player.boostFuel);
        }

        function updateTail(deltaTime) {
            const segmentSpacing = 6;
            
            // Grow tail over time
            tailLength = Math.min(maxTailLength, tailLength + tailGrowthRate * deltaTime);
            
            // Add new segment
            const lastSegment = tailSegments[tailSegments.length - 1];
            if (!lastSegment || Utils.distance(player, lastSegment) >= segmentSpacing) {
                tailSegments.push({
                    x: player.x,
                    y: player.y,
                    time: gameTime
                });
            }
            
            // Limit tail length to current growth
            const maxSegments = Math.floor(tailLength);
            while (tailSegments.length > maxSegments) {
                tailSegments.shift();
            }
            
            // Check for tail collision warning and damage
            const safetyGap = 15;
            let closestDistance = Infinity;
            let warningShown = false;
            
            if (tailSegments.length > safetyGap + 5 && player.invulnerable <= 0) {
                const playerPos = { x: player.x, y: player.y };
                
                for (let i = 0; i < tailSegments.length - safetyGap; i++) {
                    if (i >= tailSegments.length - 1) continue;
                    
                    const seg1 = tailSegments[i];
                    const seg2 = tailSegments[i + 1] || seg1;
                    const distance = Utils.distPointToSegment(playerPos, seg1, seg2);
                    closestDistance = Math.min(closestDistance, distance);
                    
                    // Warning zone
                    if (distance < player.radius + 15 && visualSettings.tailWarning) {
                        warningShown = true;
                    }
                    
                    // Damage zone (not instant death)
                    if (distance < player.radius + 5) {
                        damagePlayer(25 * deltaTime, 'Tail collision!');
                        addScreenShake(10, 0.1);
                        
                        // Particle effect
                        const particleCount = 2;
                        for (let p = 0; p < particleCount; p++) {
                            particles.push({
                                x: player.x + (Math.random() - 0.5) * 20,
                                y: player.y + (Math.random() - 0.5) * 20,
                                vx: (Math.random() - 0.5) * 100,
                                vy: (Math.random() - 0.5) * 100,
                                radius: 3,
                                color: '#ff4444',
                                life: 0.5,
                                maxLife: 0.5,
                                alpha: 1
                            });
                        }
                        break;
                    }
                }
            }
            
            // Show/hide tail warning
            const warningEl = document.getElementById('tailWarning');
            if (warningShown && !tailWarningShown) {
                warningEl.style.display = 'block';
                tailWarningShown = true;
            } else if (!warningShown && tailWarningShown) {
                warningEl.style.display = 'none';
                tailWarningShown = false;
            }
        }

        function firePrimary(mods) {
            const ammoStats = getAmmoStats();
            const bulletSpeed = ammoStats.speed;
            const bulletDamage = (player.damage * mods.damage * ammoStats.damage);
            let bulletCount = Math.min(player.weapon, 3);
            
            // Spread shots fire more bullets
            if (ammoCustomization.type === 'spread') {
                bulletCount = Math.min(bulletCount + 2, 5);
            }
            
            const spread = ammoCustomization.type === 'spread' ? 25 * Math.PI / 180 : 15 * Math.PI / 180;

            for (let i = 0; i < bulletCount; i++) {
                const angle = player.angle + (i - (bulletCount - 1) / 2) * (spread / (bulletCount - 1 || 1));
                
                bullets.push({
                    x: player.x + Math.cos(player.angle) * player.radius,
                    y: player.y + Math.sin(player.angle) * player.radius,
                    owner: player, // Added owner
                    vx: Math.cos(angle) * bulletSpeed,
                    vy: Math.sin(angle) * bulletSpeed,
                    radius: ammoStats.size,
                    damage: bulletDamage,
                    life: ammoStats.range,
                    color: ammoCustomization.color,
                    glowing: true,
                    bounces: ammoCustomization.type === 'piercing' ? 2 : 1,
                    ammoType: ammoCustomization.type,
                    piercing: ammoCustomization.type === 'piercing',
                    explosive: ammoCustomization.type === 'explosive',
                    active: true
                });
                
                // Split bullets from inhibitors - simplified
                if (mods.tags.split && Math.random() < 0.3) {
                    bullets.push({
                        x: player.x + Math.cos(player.angle) * player.radius,
                        y: player.y + Math.sin(player.angle) * player.radius,
                        owner: player, // Added owner
                        vx: Math.cos(angle + 0.3) * bulletSpeed * 0.8,
                        vy: Math.sin(angle + 0.3) * bulletSpeed * 0.8,
                        radius: Math.max(1, ammoStats.size - 1),
                        damage: bulletDamage * 0.6,
                        life: ammoStats.range,
                        color: ammoCustomization.color,
                        glowing: true,
                        bounces: 1,
                        ammoType: ammoCustomization.type,
                        piercing: ammoCustomization.type === 'piercing',
                        explosive: ammoCustomization.type === 'explosive',
                        active: true
                    });
                }
            }
            gameStats.shotsFired += bulletCount;

            playSFX('hit');
            if (mods.tags.shake || ammoCustomization.type === 'explosive') {
                addScreenShake(ammoCustomization.type === 'explosive' ? 5 : 3, 0.1);
            }
        }
        
        function getAmmoStats() {
            const stats = {
                speed: 700,
                damage: 1,
                size: 3,
                range: 3
            };
            
            // Size modifications
            switch (ammoCustomization.size) {
                case 'small':
                    stats.speed = 900;
                    stats.damage = 0.7;
                    stats.size = 2;
                    stats.range = 4;
                    break;
                case 'large':
                    stats.speed = 500;
                    stats.damage = 1.5;
                    stats.size = 5;
                    stats.range = 2.5;
                    break;
                default: // medium
                    break;
            }
            
            // Type modifications
            switch (ammoCustomization.type) {
                case 'piercing':
                    stats.damage *= 1.2;
                    stats.size *= 0.8;
                    break;
                case 'explosive':
                    stats.damage *= 1.3;
                    stats.speed *= 0.9;
                    break;
                case 'spread':
                    stats.damage *= 0.8;
                    stats.size *= 0.9;
                    break;
                default: // standard
                    break;
            }
            
            return stats;
        }
        
        function fireSecondary(chargeLevel, damageMultiplier = 1.0) {
            const bulletSpeed = 1200; // Faster bullet
            const baseDamage = player.damage * 8; // Significantly more base damage
            const damage = baseDamage * (1 + chargeLevel * 3) * damageMultiplier; // Higher charge multiplier
            const size = 8 + chargeLevel * 6; // Bigger when charged
            
            const bullet = {
                x: player.x + Math.cos(player.angle) * player.radius,
                y: player.y + Math.sin(player.angle) * player.radius,
                owner: player, // Added owner
                vx: Math.cos(player.angle) * bulletSpeed,
                vy: Math.sin(player.angle) * bulletSpeed,
                radius: size,
                damage: damage,
                life: 5,
                color: chargeLevel > 0.8 ? '#ff0080' : '#ffff00',
                glowing: true,
                bounces: 2, // Can bounce twice
                secondary: true
            };
            
            bullets.push(bullet);
            gameStats.shotsFired++;
            
            // Explosion particles
            for (let i = 0; i < 10; i++) {
                const angle = Utils.rand(0, Math.PI * 2);
                const speed = Utils.rand(100, 200);
                particles.push({
                    x: bullet.x,
                    y: bullet.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    radius: Utils.rand(2, 4),
                    color: bullet.color,
                    life: 0.8,
                    maxLife: 0.8,
                    alpha: 1
                });
            }
            
            playSFX('explosion');
            addScreenShake(8, 0.2);
        }

        function getBulletColor(mods) {
            if (mods.tags.rainbow) return Utils.rainbow(gameTime * 200);
            if (mods.tags.electric) return '#00ffff';
            if (mods.tags.toxic) return '#00ff00';
            if (mods.tags.beam) return '#ff0080';
            return ammoCustomization.color;
        }

        function damagePlayer(amount, reason = '') {
            const mods = calculateModifiers();
            
            // Shield absorption
            if (player.shield > 0) {
                const shieldAbsorbed = Math.min(player.shield, amount);
                player.shield -= shieldAbsorbed;
                amount -= shieldAbsorbed;
                
                // Shield break effect
                if (player.shield <= 0) {
                    explode(player.x, player.y, 15, '#00ffff');
                    playSFX('pickup');
                }
            }
            
            // Time warp effect when critically injured
            if (mods.tags.timeWarp && player.hp / player.maxHp < 0.3) {
                // This would need to be implemented with a global time scale
            }
            
            // Ghost mode invulnerability extension
            if (mods.tags.ghostMode) {
                player.invulnerable = Math.max(player.invulnerable, 2.0); // Longer invulnerability
            }
            
            // ...
            
            player.hp -= amount;
            if (amount > 0) { // Only increment if actual HP damage occurred
                gameStats.playerHitCount++;
            }
            player.invulnerable = Math.max(player.invulnerable, 1.5);
            
            addScreenShake(15, 0.25);
            
            if (reason) console.log(`Player damaged: ${amount} (${reason})`);

            // Flash damage overlay
            if (!flashingEffectsDisabled) {
                const damageOverlay = document.getElementById('damageOverlay');
                damageOverlay.style.display = 'block';
                setTimeout(() => {
                    damageOverlay.style.display = 'none';
                }, 100); // 100ms flash
            }
        }

        // Enhanced Enemy System
        function spawnAdvancedEnemy() {
            const difficulty = GAME_CONFIG.DIFFICULTIES[selectedDifficulty];
            const types = ['chaser', 'orbiter', 'shooter', 'bomber', 'strafe', 'sniper'];
            let weights = waveData.escalationPhase ? [1, 1, 2, 1, 1, 1] : [2, 2, 2, 0.5, 1, 0.3];
            
            // Adjust weights based on player learning state
            // If player is aggressive, increase snipers/evasive enemies
            // If player is passive, increase chasers
            if (playerLearningState.playerAggression > 0.7) { // Player is very aggressive
                weights[0] *= 0.8; // Chasers slightly less (player comes to them)
                weights[3] *= 1.2; // Bombers more
                weights[4] *= 1.5; // Strafers more
                weights[5] *= 1.5; // Snipers more
            } else if (playerLearningState.playerAggression < 0.3) { // Player is passive
                weights[0] *= 1.5; // Chasers more
                weights[1] *= 1.2; // Orbiters more
                weights[5] *= 0.5; // Snipers less
            }
            
            // If player accuracy is high, make enemies more evasive
            if (playerLearningState.playerAccuracy > 0.7) {
                weights[1] *= 1.5; // Orbiters (evasive)
                weights[4] *= 1.5; // Strafers (evasive)
            } else if (playerLearningState.playerAccuracy < 0.3) {
                weights[0] *= 1.2; // Chasers (easier to hit)
            }

            // Weighted random selection
            let totalWeight = weights.reduce((a, b) => a + b);
            let random = Math.random() * totalWeight;
            let type = 'chaser';
            for (let i = 0; i < types.length; i++) {
                random -= weights[i];
                if (random <= 0) {
                    type = types[i];
                    break;
                }
            }
            
            // Spawn from edges
            const side = Utils.randInt(0, 3);
            let x, y;
            
            switch (side) {
                case 0: x = -40; y = Utils.rand(50, GAME_CONFIG.CANVAS_HEIGHT - 50); break;
                case 1: x = GAME_CONFIG.CANVAS_WIDTH + 40; y = Utils.rand(50, GAME_CONFIG.CANVAS_HEIGHT - 50); break;
                case 2: x = Utils.rand(50, GAME_CONFIG.CANVAS_WIDTH - 50); y = -40; break;
                case 3: x = Utils.rand(50, GAME_CONFIG.CANVAS_WIDTH - 50); y = GAME_CONFIG.CANVAS_HEIGHT + 40; break;
            }

            // Apply adaptive difficulty offset to enemy stats
            const adaptiveMult = 1 + playerLearningState.adaptiveDifficultyOffset * 0.5; // Max 25% change
            
            const baseHp = (8 + gameStats.level * 2) * adaptiveMult;
            const enemy = {
                x, y,
                vx: 0, vy: 0,
                type,
                radius: getEnemyRadius(type),
                hp: baseHp * difficulty.enemyHpMult * getEnemyHpMult(type),
                maxHp: baseHp * difficulty.enemyHpMult * getEnemyHpMult(type),
                speed: (70 + gameStats.level * 5) * Utils.rand(0.8, 1.2) * getEnemySpeedMult(type) * adaptiveMult,
                damage: 15 * difficulty.enemyDmgMult * getEnemyDamageMult(type) * adaptiveMult,
                color: getEnemyColor(type),
                fireTimer: Utils.rand(0.5, 2),
                state: 'seek',
                stateTimer: 0,
                chargeTimer: 0,
                lastPlayerPos: {x: player.x, y: player.y},
                avoidsTail: Math.random() < 0.3, // Only 30% of enemies avoid tail
                lastHitBy: null // Initialize last hit tracker
            };

            enemies.push(enemy);
        }
        
        function getEnemyRadius(type) {
            switch (type) {
                case 'bomber': return Utils.rand(12, 18);
                case 'sniper': return Utils.rand(6, 10);
                case 'strafe': return Utils.rand(8, 12);
                default: return Utils.rand(8, 15);
            }
        }
        
        function getEnemyHpMult(type) {
            switch (type) {
                case 'bomber': return 1.5;
                case 'sniper': return 0.7;
                case 'strafe': return 0.9;
                default: return 1.0;
            }
        }
        
        function getEnemySpeedMult(type) {
            switch (type) {
                case 'chaser': return 1.2;
                case 'bomber': return 0.8;
                case 'sniper': return 0.4;
                case 'strafe': return 1.1;
                default: return 1.0;
            }
        }
        
        function getEnemyDamageMult(type) {
            switch (type) {
                case 'bomber': return 2.0;
                case 'sniper': return 3.0;
                case 'strafe': return 0.8;
                default: return 1.0;
            }
        }
        
        function getEnemyColor(type) {
            switch (type) {
                case 'chaser': return `hsl(${Utils.randInt(0, 60)}, 100%, 60%)`;
                case 'bomber': return `hsl(${Utils.randInt(10, 30)}, 100%, 50%)`;
                case 'sniper': return `hsl(${Utils.randInt(240, 280)}, 80%, 60%)`;
                case 'strafe': return `hsl(${Utils.randInt(120, 180)}, 90%, 55%)`;
                default: return `hsl(${Utils.randInt(0, 360)}, 80%, 60%)`;
            }
        }

        function updateEnemies(deltaTime) {
            // Clear and populate spatial hash
            spatialHash.clear();
            tailSegments.forEach((seg, i) => {
                if (i > 0) spatialHash.add({type: 'tail', seg: seg, prevSeg: tailSegments[i-1]}, seg.x, seg.y);
            });
            
            enemies.forEach(enemy => {
                const distToPlayer = Utils.distance(enemy, player);
                const angleToPlayer = Utils.angleTo(enemy, player);
                
                // Update state timer
                enemy.stateTimer += deltaTime;
                enemy.fireTimer = Math.max(0, enemy.fireTimer - deltaTime);
                enemy.chargeTimer = Math.max(0, enemy.chargeTimer - deltaTime);
                
                // Enhanced AI with state machine and tail avoidance
                updateEnemyAI(enemy, deltaTime, distToPlayer, angleToPlayer);

                // Apply movement
                enemy.x += enemy.vx * deltaTime;
                enemy.y += enemy.vy * deltaTime;
                
                // Keep enemies roughly on screen
                enemy.x = Utils.clamp(enemy.x, -50, GAME_CONFIG.CANVAS_WIDTH + 50);
                enemy.y = Utils.clamp(enemy.y, -50, GAME_CONFIG.CANVAS_HEIGHT + 50);
            });

            // Remove dead enemies
            enemies = enemies.filter(enemy => {
                if (enemy.hp <= 0) {
                    onEnemyKilled(enemy);
                    return false;
                }
                return true;
            });
        }
        
        function updateEnemyAI(enemy, deltaTime, distToPlayer, angleToPlayer) {
            // Adaptive scaling for enemy speed and aggression
            const aggressionFactor = 1 + (playerLearningState.playerAggression - 0.5) * 0.4; // 0.8 to 1.2
            const evasivenessFactor = 1 + (playerLearningState.playerEvasiveness - 0.5) * 0.4; // 0.8 to 1.2
            const accuracyFactor = 1 + (playerLearningState.playerAccuracy - 0.5) * 0.4; // 0.8 to 1.2

            let currentEnemySpeed = enemy.speed * aggressionFactor;
            let currentEnemyFireRate = enemy.fireRate || (enemy.type === 'sniper' ? 0.4 : 1.5);
            
            // Tail avoidance check (only for special enemies)
            const nearbyTail = spatialHash.query(enemy.x, enemy.y, enemy.radius + 20);
            let avoidanceVector = {x: 0, y: 0};
            let tailThreat = false;
            
            if (enemy.avoidsTail) {
                nearbyTail.forEach(obj => {
                    if (obj.type === 'tail') {
                        const dist = Utils.distPointToSegment({x: enemy.x, y: enemy.y}, obj.prevSeg, obj.seg);
                        if (dist < enemy.radius + 15) {
                            tailThreat = true;
                            const perpAngle = Utils.angleTo(obj.seg, {x: enemy.x, y: enemy.y}) + Math.PI/2;
                            avoidanceVector.x += Math.cos(perpAngle) * (30 - dist);
                            avoidanceVector.y += Math.sin(perpAngle) * (30 - dist);
                        }
                    }
                });
            }
            
            // State-based AI
            switch (enemy.type) {
                case 'chaser':
                    if (tailThreat) {
                        enemy.vx = avoidanceVector.x * 2;
                        enemy.vy = avoidanceVector.y * 2;
                    } else {
                        // Predictive chasing with adaptive speed
                        const leadTime = distToPlayer / currentEnemySpeed * 0.3 * evasivenessFactor; // Lead more if player is evasive
                        const targetX = player.x + player.vx * leadTime;
                        const targetY = player.y + player.vy * leadTime;
                        const leadAngle = Math.atan2(targetY - enemy.y, targetX - enemy.x);
                        enemy.vx = Math.cos(leadAngle) * currentEnemySpeed;
                        enemy.vy = Math.sin(leadAngle) * currentEnemySpeed;
                    }
                    // Chasers fire more often if player is aggressive and close
                    if (playerLearningState.playerAggression > 0.6 && distToPlayer < 100) {
                        currentEnemyFireRate *= 1.2;
                    }
                    break;
                    
                case 'bomber':
                    if (enemy.state === 'seek' && distToPlayer < 80) {
                        enemy.state = 'charge';
                        enemy.chargeTimer = 1.0; // 1 second charge
                        enemy.vx = 0;
                        enemy.vy = 0;
                    } else if (enemy.state === 'charge') {
                        if (enemy.chargeTimer <= 0) {
                            // Explode
                            explodeEnemy(enemy, 60); // Large explosion
                            enemy.hp = 0; // Mark for removal
                        }
                    } else {
                        // Normal seeking with avoidance
                        if (tailThreat) {
                            enemy.vx = avoidanceVector.x;
                            enemy.vy = avoidanceVector.y;
                        } else {
                            enemy.vx = Math.cos(angleToPlayer) * currentEnemySpeed * 0.8;
                            enemy.vy = Math.sin(angleToPlayer) * currentEnemySpeed * 0.8;
                        }
                    }
                    // Bombers might explode faster if player is less evasive
                    if (playerLearningState.playerEvasiveness < 0.4) {
                        enemy.chargeTimer = Math.max(0, enemy.chargeTimer - deltaTime * 0.2); // Charge 20% faster
                    }
                    break;
                    
                case 'strafe':
                    // Circle strafe with shooting, adapt strafe pattern
                    const perpAngle = angleToPlayer + Math.PI / 2;
                    const idealDist = 120 * evasivenessFactor; // Strafe wider if player is less evasive
                    let seekWeight = distToPlayer > idealDist ? 0.6 : 0.2;
                    if (tailThreat) {
                        enemy.vx = avoidanceVector.x;
                        enemy.vy = avoidanceVector.y;
                    } else {
                        enemy.vx = Math.cos(angleToPlayer) * currentEnemySpeed * seekWeight + 
                                   Math.cos(perpAngle) * currentEnemySpeed * (1 - seekWeight);
                        enemy.vy = Math.sin(angleToPlayer) * currentEnemySpeed * seekWeight + 
                                   Math.sin(perpAngle) * currentEnemySpeed * (1 - seekWeight);
                    }
                    
                    if (enemy.fireTimer <= 0 && distToPlayer < 200 && distToPlayer > 60) {
                        enemyShoot(enemy);
                        enemy.fireTimer = 0.8 / aggressionFactor; // Fire faster if player is aggressive
                    }
                    break;
                    
                case 'sniper':
                    // Stay at distance and charge powerful shots, adapt distance
                    const snipeDistance = 250 * aggressionFactor; // Snipe further if player is less aggressive
                    if (distToPlayer < snipeDistance - 50) {
                        const fleeAngle = angleToPlayer + Math.PI;
                        enemy.vx = Math.cos(fleeAngle) * currentEnemySpeed;
                        enemy.vy = Math.sin(fleeAngle) * currentEnemySpeed;
                    } else if (distToPlayer > snipeDistance + 50) {
                        enemy.vx = Math.cos(angleToPlayer) * currentEnemySpeed * 0.5;
                        enemy.vy = Math.sin(angleToPlayer) * currentEnemySpeed * 0.5;
                    } else {
                        enemy.vx *= 0.95; // Slow down to aim
                        enemy.vy *= 0.95;
                    }
                    
                    if (enemy.fireTimer <= 0 && distToPlayer > snipeDistance - 100 && distToPlayer < snipeDistance + 100) {
                        enemySniperShot(enemy);
                        enemy.fireTimer = 2.5 / accuracyFactor; // Fire faster if player is less accurate
                    }
                    break;
                    
                default: // Orbiter/Shooter types
                    if (enemy.type === 'orbiter') {
                        const perpAngle = angleToPlayer + Math.PI / 2;
                        const seekWeight = distToPlayer > 100 ? 0.8 : 0.3;
                        if (tailThreat) {
                            enemy.vx = avoidanceVector.x;
                            enemy.vy = avoidanceVector.y;
                        } else {
                            enemy.vx = Math.cos(angleToPlayer) * currentEnemySpeed * seekWeight + 
                                       Math.cos(perpAngle) * currentEnemySpeed * (1 - seekWeight);
                            enemy.vy = Math.sin(angleToPlayer) * currentEnemySpeed * seekWeight + 
                                       Math.sin(perpAngle) * currentEnemySpeed * (1 - seekWeight);
                        }
                    } else { // Shooter behavior
                        const idealShooterDistance = 180 * evasivenessFactor; // Keep ideal distance if player is less evasive
                        if (distToPlayer < idealShooterDistance - 30) {
                            const fleeAngle = angleToPlayer + Math.PI;
                            enemy.vx = Math.cos(fleeAngle) * currentEnemySpeed * 0.8;
                            enemy.vy = Math.sin(fleeAngle) * currentEnemySpeed * 0.8;
                        } else if (distToPlayer > idealShooterDistance + 30) {
                            enemy.vx = Math.cos(angleToPlayer) * currentEnemySpeed * 0.6;
                            enemy.vy = Math.sin(angleToPlayer) * currentEnemySpeed * 0.6;
                        } else {
                            const strafeAngle = angleToPlayer + Math.PI / 2 + Math.sin(gameTime * accuracyFactor) * 0.5; // More erratic strafe if player is accurate
                            enemy.vx = Math.cos(strafeAngle) * currentEnemySpeed * 0.7;
                            enemy.vy = Math.sin(strafeAngle) * currentEnemySpeed * 0.7;
                        }
                        
                        if (enemy.fireTimer <= 0 && distToPlayer < 250) {
                            enemyShoot(enemy);
                            enemy.fireTimer = 1.5 / aggressionFactor; // Fire faster if player is aggressive
                        }
                    }
                    break;
            }
        }

        function enemyShoot(enemy) {
            // Don't shoot until level 20
            if (gameStats.level < 20) return;
            
            const angleToPlayer = Utils.angleTo(enemy, player);
            
            // Predictive aiming
            const bulletSpeed = 300;
            const timeToHit = Utils.distance(enemy, player) / bulletSpeed;
            const predictedX = player.x + player.vx * timeToHit;
            const predictedY = player.y + player.vy * timeToHit;
            const predictedAngle = Math.atan2(predictedY - enemy.y, predictedX - enemy.x);
            
            bullets.push({
                x: enemy.x,
                y: enemy.y,
                vx: Math.cos(predictedAngle) * bulletSpeed,
                vy: Math.sin(predictedAngle) * bulletSpeed,
                radius: 4,
                damage: 15,
                life: 3,
                color: '#ff4444',
                enemyBullet: true
            });
        }
        
        function enemySniperShot(enemy) {
            // Don't shoot until level 20
            if (gameStats.level < 20) return;
            
            const angleToPlayer = Utils.angleTo(enemy, player);
            
            // Create charge-up visual effect
            for (let i = 0; i < 15; i++) {
                const angle = Utils.rand(0, Math.PI * 2);
                const speed = Utils.rand(20, 40);
                particles.push({
                    x: enemy.x + Math.cos(angle) * enemy.radius,
                    y: enemy.y + Math.sin(angle) * enemy.radius,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    radius: 2,
                    color: '#ff00ff',
                    life: 0.8,
                    maxLife: 0.8,
                    alpha: 1
                });
            }
            
            // Powerful sniper bullet
            const bulletSpeed = 500;
            const timeToHit = Utils.distance(enemy, player) / bulletSpeed;
            const predictedX = player.x + player.vx * timeToHit * 0.8; // Less prediction for balance
            const predictedY = player.y + player.vy * timeToHit * 0.8;
            const predictedAngle = Math.atan2(predictedY - enemy.y, predictedX - enemy.x);
            
            bullets.push({
                x: enemy.x,
                y: enemy.y,
                vx: Math.cos(predictedAngle) * bulletSpeed,
                vy: Math.sin(predictedAngle) * bulletSpeed,
                radius: 6,
                damage: enemy.damage,
                life: 4,
                color: '#ff00ff',
                enemyBullet: true,
                sniper: true
            });
            
            addScreenShake(3, 0.15);
            playSFX('hit');
        }
        
        function explodeEnemy(enemy, particleCount) {
            // Large explosion for bombers
            for (let i = 0; i < particleCount; i++) {
                const angle = Utils.rand(0, Math.PI * 2);
                const speed = Utils.rand(50, 200);
                particles.push({
                    x: enemy.x,
                    y: enemy.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    radius: Utils.rand(2, 8),
                    color: enemy.color,
                    life: Utils.rand(0.8, 2.0),
                    maxLife: Utils.rand(0.8, 2.0),
                    alpha: 1
                });
            }
            
            // Damage player if nearby
            const distToPlayer = Utils.distance(enemy, player);
            const blastRadius = enemy.radius * 4;
            if (distToPlayer < blastRadius && player.invulnerable <= 0) {
                const damage = enemy.damage * (1 - distToPlayer / blastRadius);
                damagePlayer(damage, 'Explosion');
                addScreenShake(20, 0.4);
            }
            
            playSFX('explosion');
        }

        function onEnemyKilled(enemy) {
            gameStats.enemiesKilled++;
            const points = (enemy.maxHp || 30) + gameStats.level * 10;
            if (enemy.lastHitBy === 'player') {
                gameStats.playerScore += points;
            } else if (enemy.lastHitBy && (enemy.lastHitBy.type === 'ally' || enemy.lastHitBy.type === 'support')) { // Now an object
                enemy.lastHitBy.score += points; // Update individual ally's score
                gameStats.allyScore += points; // Update aggregate ally score
            } else { // Default to player if not specified
                gameStats.playerScore += points;
            }
            gameStats.score = gameStats.playerScore + gameStats.allyScore; // Total score
            
            playSFX('explosion');
            
            // Chance to drop a power-up
            if (Math.random() < 0.1) { // 10% general chance to drop a power-up
                let typeToDrop;
                const activeMainAllies = friendlyBots.filter(bot => bot.type === 'ally');
                
                // If there are dead allies and random chance is good, drop ally_respawn
                if (activeMainAllies.length < allyConfig.count && Math.random() < 0.5) { // 50% chance for ally_respawn if applicable
                    typeToDrop = 'ally_respawn';
                } else {
                    // Otherwise, drop a random power-up, excluding ally_respawn if all allies are present
                    const availablePowerUps = Object.keys(powerUpTypes).filter(type => 
                        !(type === 'ally_respawn' && activeMainAllies.length >= allyConfig.count));
                    typeToDrop = availablePowerUps[Math.floor(Math.random() * availablePowerUps.length)];
                }
                
                powerUps.push({
                    x: enemy.x,
                    y: enemy.y,
                    type: typeToDrop,
                    radius: 8,
                    life: 10 // 10 seconds to pick up
                });
            }
            
            if (enemy.radius > 12) {
                addScreenShake(5, 0.1);
            }
        }

        // Optimized Particle System using object pooling
        function explode(x, y, count, color) {
            if (!graphicsSettings.visualEffects) return;
            
            // Heavily reduce particle count for performance
            let particleCount = Math.max(1, Math.floor(count * 0.3));
            if (graphicsSettings.particleQuality === 'medium') particleCount = Math.floor(particleCount * 0.7);
            else if (graphicsSettings.particleQuality === 'low') particleCount = Math.floor(particleCount * 0.4);

            if (flashingEffectsDisabled) {
                particleCount = Math.min(1, particleCount); // Drastically reduce particles
            }
            
            // Create particles directly without pooling complexity
            for (let i = 0; i < particleCount; i++) {
                const angle = Utils.rand(0, Math.PI * 2);
                const speed = Utils.rand(50, 120);
                
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    radius: Utils.rand(1, 2),
                    color,
                    life: Utils.rand(0.2, 0.6),
                    maxLife: Utils.rand(0.2, 0.6),
                    alpha: 1,
                    active: true
                });
            }
        }

        function updateParticles(deltaTime) {
            // Simple particle update without pooling complexity
            particles = particles.filter(particle => {
                particle.x += particle.vx * deltaTime;
                particle.y += particle.vy * deltaTime;
                particle.life -= deltaTime;
                
                particle.vx *= 0.98;
                particle.vy *= 0.98;
                
                particle.alpha = Utils.clamp(particle.life / particle.maxLife, 0, 1);
                
                return particle.life > 0;
            });
        }


        function updatePowerUps(deltaTime) {
            powerUps = powerUps.filter(p => {
                if (p.collected) {
                    p.collectionTime += deltaTime;
                    // Animation logic here (e.g., shrink and fade)
                    p.radius = Math.max(0, p.radius - 30 * deltaTime);
                    p.alpha = 1 - p.collectionTime / 0.5; // 0.5 second fade out
                    return p.collectionTime < 0.5;
                }
                p.life -= deltaTime;
                // Bobbing motion
                p.y += Math.sin(p.life * 2) * 0.2;
                return p.life > 0;
            });
        }

        function renderPowerUps() {
            powerUps.forEach(p => {
                const config = powerUpTypes[p.type];
                ctx.save();
                ctx.globalAlpha = p.alpha === undefined ? 1 : p.alpha;
                ctx.fillStyle = config.color;
                ctx.shadowColor = config.color;
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'white';
                ctx.font = 'bold 10px monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(config.symbol, p.x, p.y);
                ctx.restore();
            });
        }

        function handleCollisions() {
            const mods = calculateModifiers();

            // Player vs Power-ups
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const p = powerUps[i];
                if (Utils.distance(player, p) < player.radius + p.radius && !p.collected) {
                    p.collected = true;
                    p.collectionTime = 0; // Start animation timer
                    const config = powerUpTypes[p.type];
                    config.apply(player);
                    playSFX('pickup');
                }
            }
            
            // Bullets vs Enemies
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                if (bullet.enemyBullet) continue;
                
                let bulletRemoved = false;
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    
                    if (Utils.distance(bullet, enemy) < bullet.radius + enemy.radius) {
                        if (!bullet.enemyBullet) {
                            gameStats.shotsHit++;
                            if (bullet.owner === player) enemy.lastHitBy = 'player';
                            else if (bullet.owner && (bullet.owner.type === 'ally' || bullet.owner.type === 'support')) enemy.lastHitBy = bullet.owner;
                        }
                        enemy.hp -= bullet.damage;
                        
                        // Explosive bullets create explosion
                        if (bullet.explosive) {
                            explode(enemy.x, enemy.y, 15, bullet.color);
                            // Damage nearby enemies
                            enemies.forEach(nearEnemy => {
                                if (nearEnemy !== enemy && Utils.distance(enemy, nearEnemy) < 40) {
                                    nearEnemy.hp -= bullet.damage * 0.5;
                                }
                            });
                            addScreenShake(8, 0.15);
                        } else {
                            explode(enemy.x, enemy.y, 5, bullet.color);
                        }
                        
                        playSFX(bullet.explosive ? 'explosion' : 'hit');
                        gameStats.score += Math.floor(bullet.damage);
                        
                        // Piercing bullets don't get removed on first hit
                        if (!bullet.piercing) {
                            bullets.splice(i, 1);
                            bulletRemoved = true;
                        } else {
                            // Reduce piercing bullet damage after each hit
                            bullet.damage *= 0.8;
                        }
                        break;
                    }
                }
                
                if (bulletRemoved) continue;
            }

            // Enemy bullets vs Player and friendly bots
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                if (!bullet.enemyBullet) continue;
                
                // Check collision with player
                if (player.invulnerable <= 0 && 
                    Utils.distance(bullet, player) < bullet.radius + player.radius) {
                    damagePlayer(bullet.damage, 'Enemy bullet');
                    bullets.splice(i, 1);
                    continue;
                }
                
                // Check collision with friendly bots
                for (let j = friendlyBots.length - 1; j >= 0; j--) {
                    const bot = friendlyBots[j];
                    if (Utils.distance(bullet, bot) < bullet.radius + bot.radius) {
                        bot.hp -= bullet.damage;
                        bullets.splice(i, 1);
                        
                        explode(bot.x, bot.y, 8, '#00ff88');
                        playSFX('hit');
                        
                        if (bot.hp <= 0) {
                            friendlyBots.splice(j, 1);
                            explode(bot.x, bot.y, 20, '#00ff88');
                        }
                        break;
                    }
                }
            }

            // Ally vs Power-ups
            friendlyBots.forEach(bot => {
                for (let i = powerUps.length - 1; i >= 0; i--) {
                    const p = powerUps[i];
                    if (!p.collected && Utils.distance(bot, p) < bot.radius + p.radius) {
                        p.collected = true;
                        p.collectionTime = 0; // Start animation
                        const config = powerUpTypes[p.type];
                        config.apply(player); // Apply effect to the player
                        playSFX('pickup');
                    }
                }
            });

            // Player vs Enemies
            if (player.invulnerable <= 0) {
                enemies.forEach(enemy => {
                    if (Utils.distance(player, enemy) < player.radius + enemy.radius - 3) {
                        damagePlayer(enemy.damage || 20, `Hit by ${enemy.type || 'enemy'}`);
                    }
                });
            }
            
            // Player ammo and tail vs Friendly bots (only on hard difficulty)
            if (selectedDifficulty === 'hard') {
                // Player bullets vs friendly bots
                for (let i = bullets.length - 1; i >= 0; i--) {
                    const bullet = bullets[i];
                    if (bullet.enemyBullet || bullet.friendlyFire === false) continue;
                    
                    for (let j = friendlyBots.length - 1; j >= 0; j--) {
                        const bot = friendlyBots[j];
                        if (Utils.distance(bullet, bot) < bullet.radius + bot.radius) {
                            bot.hp -= bullet.damage;
                            bullets.splice(i, 1);
                            
                            explode(bot.x, bot.y, 8, '#ffaa00');
                            playSFX('hit');
                            
                            if (bot.hp <= 0) {
                                friendlyBots.splice(j, 1);
                                explode(bot.x, bot.y, 20, '#ffaa00');
                                showToast('Friendly fire!', 'warning');
                            }
                            break;
                        }
                    }
                }
                
                // Player tail vs friendly bots
                friendlyBots.forEach((bot, botIndex) => {
                    for (let i = 0; i < tailSegments.length - 1; i++) {
                        const seg1 = tailSegments[i];
                        const seg2 = tailSegments[i + 1];
                        const distance = Utils.distPointToSegment(bot, seg1, seg2);
                        
                        if (distance < bot.radius + 3) {
                            bot.hp -= 20;
                            
                            if (Math.random() < 0.3) {
                                particles.push({
                                    x: bot.x + (Math.random() - 0.5) * 20,
                                    y: bot.y + (Math.random() - 0.5) * 20,
                                    vx: (Math.random() - 0.5) * 100,
                                    vy: (Math.random() - 0.5) * 100,
                                    radius: 3,
                                    color: '#ffaa00',
                                    life: 0.5,
                                    maxLife: 0.5,
                                    alpha: 1
                                });
                            }
                            
                            if (bot.hp <= 0) {
                                friendlyBots.splice(botIndex, 1);
                                explode(bot.x, bot.y, 20, '#ffaa00');
                                showToast('Bot destroyed by tail!', 'warning');
                            }
                            break;
                        }
                    }
                });
            }

            // Tail vs Enemies (powerful but not overpowered)
            const baseTailDamage = 30 + mods.effects.tailBoost * 30; // Strong tail damage
            const tailDamage = baseTailDamage * 0.016; // ~60fps
            
            enemies.forEach(enemy => {
                for (let i = 0; i < tailSegments.length - 1; i++) {
                    const seg1 = tailSegments[i];
                    const seg2 = tailSegments[i + 1];
                    const distance = Utils.distPointToSegment(enemy, seg1, seg2);
                    
                    if (distance < enemy.radius + 3) { // Slightly smaller hitbox
                        enemy.hp -= tailDamage;
                        
                        if (Math.random() < 0.15) {
                            particles.push({
                                x: enemy.x + (Math.random() - 0.5) * 20,
                                y: enemy.y + (Math.random() - 0.5) * 20,
                                vx: (Math.random() - 0.5) * 100,
                                vy: (Math.random() - 0.5) * 100,
                                radius: 3,
                                color: mods.tags.toxic ? '#00ff00' : '#00ffff',
                                life: 0.5,
                                maxLife: 0.5,
                                alpha: 1
                            });
                        }
                        break;
                    }
                }
            });
        }

        // Advanced Wave and Spawn System
        let waveData = {
            duration: 0,
            maxDuration: 45,
            killsRequired: 20,
            escalationPhase: false,
            spawnIntensity: 1.0
        };
        
        let spatialHash = {
            cellSize: 64,
            cells: new Map(),
            clear() {
                this.cells.clear();
            },
            hash(x, y) {
                const gx = Math.floor(x / this.cellSize);
                const gy = Math.floor(y / this.cellSize);
                return `${gx},${gy}`;
            },
            add(obj, x, y) {
                const key = this.hash(x, y);
                if (!this.cells.has(key)) this.cells.set(key, []);
                this.cells.get(key).push(obj);
            },
            query(x, y, radius) {
                const results = [];
                const range = Math.ceil(radius / this.cellSize);
                const gx = Math.floor(x / this.cellSize);
                const gy = Math.floor(y / this.cellSize);
                
                for (let dx = -range; dx <= range; dx++) {
                    for (let dy = -range; dy <= range; dy++) {
                        const key = `${gx + dx},${gy + dy}`;
                        const cell = this.cells.get(key);
                        if (cell) results.push(...cell);
                    }
                }
                return results;
            }
        };
        
        function updateWaveSystem(deltaTime) {
            const difficulty = GAME_CONFIG.DIFFICULTIES[selectedDifficulty];
            waveData.duration += deltaTime;
            waveData.maxDuration = 45 * (difficulty.waveDurationMult || 1);
            waveData.killsRequired = Math.floor(20 * (difficulty.killsToAdvanceMult || 1));
            
            // Escalation phase in last 25% of wave
            const progress = waveData.duration / waveData.maxDuration;
            waveData.escalationPhase = progress > 0.75;
            waveData.spawnIntensity = waveData.escalationPhase ? 2.5 : (1 + progress * 0.5);
            
            // Check wave completion
            if ((gameStats.enemiesKilled >= waveData.killsRequired && waveData.duration >= waveData.maxDuration * 0.5) ||
                waveData.duration >= waveData.maxDuration) {
                nextWave();
                waveData.duration = 0;
                waveData.spawnIntensity = 1.0;
                waveData.escalationPhase = false;
            }
        }
        
        function handleSpawning(deltaTime) {
            const difficulty = GAME_CONFIG.DIFFICULTIES[selectedDifficulty];
            const baseMaxEnemies = 20;
            const maxEnemies = Math.floor(baseMaxEnemies * difficulty.enemyCountMult * waveData.spawnIntensity);
            
            enemySpawnTimer -= deltaTime;
            const baseSpawnRate = 0.4;
            const currentSpawnRate = baseSpawnRate / (difficulty.spawnRateMult * waveData.spawnIntensity);
            
            if (enemySpawnTimer <= 0 && enemies.length < maxEnemies) {
                const spawnCount = Math.max(1, Math.floor(difficulty.enemyCountMult * waveData.spawnIntensity * 0.5));
                for (let i = 0; i < spawnCount && enemies.length < maxEnemies; i++) {
                    spawnAdvancedEnemy();
                }
                enemySpawnTimer = currentSpawnRate;
            }
        }

        // Wave Progression
        function handleWaveProgression() {
            // Simple wave progression based on kills
            const killsNeeded = 20 + gameStats.wave * 5;
            if (gameStats.enemiesKilled >= killsNeeded) {
                nextWave();
            }
        }

        function nextWave() {
            gameStats.wave++;
            gameStats.enemiesKilled = 0;
            gameStats.score += gameStats.wave * 100;
            
            // --- Ally Respawn Logic ---
            // Filter out only support bots to keep them, main allies will be respawned
            friendlyBots = friendlyBots.filter(bot => bot.type === 'support');
            
            // Respawn main allies based on allyConfig.count
            for (let i = 0; i < allyConfig.count; i++) {
                spawnAlly(i); // Respawn each ally with its original index
            }
            // --- End Ally Respawn Logic ---
            
            // Level up every 3 waves
            if (gameStats.wave % 3 === 0) {
                gameStats.level++;
                const difficulty = GAME_CONFIG.DIFFICULTIES[selectedDifficulty];
                
                if (Math.random() < difficulty.upgradeSpeedMult) {
                    player.weapon = Math.min(5, player.weapon + 1);
                }
                
                player.hp = Math.min(player.maxHp, player.hp + 25);
                showToast(`Wave ${gameStats.wave}! Level ${gameStats.level}`, 'success');
                
                // Show HUD temporarily for level up (only if user hasn't manually toggled)
                if (hudAutoHide && !userToggledHud) {
                    hudLevelShowTimer = 15.0; // Show for 15 seconds
                    hudVisible = true;
                    updateHUDVisibility();
                }
            }
            
            console.log(`Wave ${gameStats.wave}, Level ${gameStats.level}`);
        }

        // Rendering System
        function render() {
            const renderStartTime = performance.now();
            
            const musicIntensity = getMusicIntensity();
            const mods = calculateModifiers();
            
            // Clear canvas first
            ctx.clearRect(0, 0, GAME_CONFIG.CANVAS_WIDTH, GAME_CONFIG.CANVAS_HEIGHT);
            
            // Clear and apply screen shake
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            
            // Apply screen shake
            let shakeX = screenShake.x || 0;
            let shakeY = screenShake.y || 0;
            ctx.translate(shakeX, shakeY);
            
            // Background - let user settings control complexity
            if (graphicsSettings.visualEffects && visualSettings.trippyEffects) {
                renderBackground(musicIntensity, mods);
            } else {
                renderBackgroundSimple();
            }
            
            // Game objects (only render if player exists)
            if (gameState === 'playing' && player) {
                renderPlayer(mods, musicIntensity);
                renderFriendlyBots(mods, musicIntensity);
                renderBullets(musicIntensity);
                renderEnemies(musicIntensity);
                renderPowerUps();
                
                // Render cursor if enabled
                if (cursorSettings.enabled) {
                    renderCursor();
                }
            }
            
            // Render particles based on user settings
            if (graphicsSettings.visualEffects) {
                renderParticles();
            }
            
            // Music overlay based on user settings
            if (musicIntensity > 0.3 && visualSettings.colorPulse) {
                renderMusicOverlay(musicIntensity);
            }
            
            ctx.restore();
            lastRenderTime = renderStartTime;
        }
        
        function renderBackgroundSimple() {
            // Ultra-simple background for performance
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, GAME_CONFIG.CANVAS_WIDTH, GAME_CONFIG.CANVAS_HEIGHT);
            
            if (!graphicsSettings.showGrid) return;
            
            // Simple static grid
            const gridSize = 80;
            ctx.strokeStyle = 'rgba(0, 240, 255, 0.1)';
            ctx.lineWidth = 1;
            
            // Vertical lines
            for (let x = 0; x < GAME_CONFIG.CANVAS_WIDTH; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, GAME_CONFIG.CANVAS_HEIGHT);
                ctx.stroke();
            }
            
            // Horizontal lines
            for (let y = 0; y < GAME_CONFIG.CANVAS_HEIGHT; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(GAME_CONFIG.CANVAS_WIDTH, y);
                ctx.stroke();
            }
        }

        function renderBackground(musicIntensity, mods) {
            const baseAlpha = 0.08;
            const reactAlpha = visualSettings.backgroundReact ? musicIntensity * 0.5 : 0;
            const bgAlpha = baseAlpha + reactAlpha;
            
            // Dynamic background color based on music and effects
            let bgColor = '#0a0a0f';
            if (visualSettings.trippyEffects && graphicsSettings.visualEffects) {
                if (musicIntensity > 0.2) {
                    const hue = (gameTime * 50 + musicIntensity * 300) % 360;
                    const intensity = Math.min(musicIntensity * 2, 1);
                    bgColor = `hsla(${hue}, ${60 + intensity * 40}%, ${8 + intensity * 12}%, 0.95)`;
                }
                
                // Additional visual effects based on inhibitors
                if (mods.tags.vaporwave) {
                    bgColor = `hsla(300, 80%, 15%, ${0.9 + musicIntensity * 0.1})`;
                } else if (mods.tags.glitchy) {
                    const glitchHue = Math.random() > 0.95 ? Math.random() * 360 : 200;
                    bgColor = `hsla(${glitchHue}, 90%, 10%, 0.9)`;
                }
            }
            
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, GAME_CONFIG.CANVAS_WIDTH, GAME_CONFIG.CANVAS_HEIGHT);
            
            // Skip grid if disabled
            if (!graphicsSettings.showGrid) return;
            
            // Animated grid that reacts to music
            const baseGridSize = 80;
            const musicGridMod = visualSettings.backgroundReact ? musicIntensity * 60 : 0;
            const gridSize = baseGridSize + musicGridMod;
            
            let gridColor = `rgba(0, 240, 255, ${bgAlpha})`;
            
            if (visualSettings.colorPulse && musicIntensity > 0.15) {
                const pulseHue = (gameTime * 120 + musicIntensity * 500) % 360;
                gridColor = `hsla(${pulseHue}, 90%, 70%, ${bgAlpha * (1 + musicIntensity)})`;
            } else if (mods.tags.rainbow) {
                const rainbowHue = (gameTime * 150 + musicIntensity * 300) % 360;
                gridColor = `hsla(${rainbowHue}, 100%, 60%, ${bgAlpha * 1.5})`;
            } else if (mods.tags.electric) {
                gridColor = `rgba(0, 255, 255, ${bgAlpha * (1 + musicIntensity * 2)})`;
            }
            
            ctx.strokeStyle = gridColor;
            ctx.lineWidth = 1 + musicIntensity * 3;
            
            const baseSpeed = 30;
            const musicSpeedMod = visualSettings.backgroundReact ? musicIntensity * 50 : 0;
            const offset = ((gameTime * (baseSpeed + musicSpeedMod)) % gridSize);
            
            // Grid lines with enhanced music-reactive distortion
            for (let x = offset; x < GAME_CONFIG.CANVAS_WIDTH; x += gridSize) {
                ctx.beginPath();
                let startY = 0;
                let endY = GAME_CONFIG.CANVAS_HEIGHT;
                
                if (visualSettings.trippyEffects && musicIntensity > 0.3 && graphicsSettings.visualEffects) {
                    const wave = Math.sin(gameTime * 4 + x * 0.008) * musicIntensity * 40;
                    const twist = Math.cos(gameTime * 2 + x * 0.005) * musicIntensity * 15;
                    ctx.moveTo(x + wave, startY + twist);
                    ctx.lineTo(x - wave, endY - twist);
                } else {
                    ctx.moveTo(x, startY);
                    ctx.lineTo(x, endY);
                }
                ctx.stroke();
            }
            
            for (let y = offset; y < GAME_CONFIG.CANVAS_HEIGHT; y += gridSize) {
                ctx.beginPath();
                let startX = 0;
                let endX = GAME_CONFIG.CANVAS_WIDTH;
                
                if (visualSettings.trippyEffects && musicIntensity > 0.3 && graphicsSettings.visualEffects) {
                    const wave = Math.cos(gameTime * 4 + y * 0.008) * musicIntensity * 40;
                    const twist = Math.sin(gameTime * 2 + y * 0.005) * musicIntensity * 15;
                    ctx.moveTo(startX + twist, y + wave);
                    ctx.lineTo(endX - twist, y - wave);
                } else {
                    ctx.moveTo(startX, y);
                    ctx.lineTo(endX, y);
                }
                ctx.stroke();
            }
            
            // Enhanced trippy effects (user controlled)
            if (visualSettings.trippyEffects && musicIntensity > 0.4 && graphicsSettings.visualEffects) {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                const centerX = GAME_CONFIG.CANVAS_WIDTH / 2;
                const centerY = GAME_CONFIG.CANVAS_HEIGHT / 2;
                
                // Reduce concentric rings for better performance
                const ringCount = fpsLimit <= 30 ? 3 : 5;
                for (let i = 0; i < ringCount; i++) {
                    const radius = (80 + musicIntensity * 300) + i * 60;
                    const hue = (gameTime * 80 + i * 72 + musicIntensity * 400) % 360;
                    const intensity = musicIntensity * (1 - i * 0.15);
                    
                    const gradient = ctx.createRadialGradient(centerX, centerY, radius * 0.3, centerX, centerY, radius);
                    gradient.addColorStop(0, `hsla(${hue}, 100%, 60%, ${intensity * 0.2})`);
                    gradient.addColorStop(0.7, `hsla(${hue}, 100%, 50%, ${intensity * 0.1})`);
                    gradient.addColorStop(1, `hsla(${hue}, 100%, 40%, 0)`);
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, GAME_CONFIG.CANVAS_WIDTH, GAME_CONFIG.CANVAS_HEIGHT);
                }
                
                // Pulsing corner effects
                if (musicIntensity > 0.6) {
                    const cornerIntensity = (musicIntensity - 0.6) * 2.5;
                    const corners = [
                        {x: 0, y: 0},
                        {x: GAME_CONFIG.CANVAS_WIDTH, y: 0},
                        {x: GAME_CONFIG.CANVAS_WIDTH, y: GAME_CONFIG.CANVAS_HEIGHT},
                        {x: 0, y: GAME_CONFIG.CANVAS_HEIGHT}
                    ];
                    
                    corners.forEach((corner, i) => {
                        const hue = (gameTime * 100 + i * 90) % 360;
                        const radius = cornerIntensity * 200;
                        const gradient = ctx.createRadialGradient(corner.x, corner.y, 0, corner.x, corner.y, radius);
                        gradient.addColorStop(0, `hsla(${hue}, 100%, 50%, ${cornerIntensity * 0.3})`);
                        gradient.addColorStop(1, `hsla(${hue}, 100%, 50%, 0)`);
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, GAME_CONFIG.CANVAS_WIDTH, GAME_CONFIG.CANVAS_HEIGHT);
                    });
                }
                
                ctx.restore();
            }
        }

        function renderFriendlyBots(mods, musicIntensity = 0) {
            friendlyBots.forEach(bot => {
                // Render ally tail if enabled
                if (bot.type === 'ally' && bot.tailEnabled && bot.tailSegments && bot.tailSegments.length > 1) {
                    ctx.save();
                    ctx.globalCompositeOperation = 'lighter';
                    
                    let trailColor = bot.tailColor || '#00ffff';
                    
                    // Apply rainbow effect for allies too
                    if (mods.tags.rainbow || (visualSettings.colorPulse && musicIntensity > 0.3)) {
                        const hue = (gameTime * 180 + bot.id * 90) % 360;
                        trailColor = `hsl(${hue}, 90%, 70%)`;
                    }
                    
                    const baseThickness = bot.tailWidth || 2;
                    const musicThickness = visualSettings.backgroundReact ? musicIntensity * 1 : 0;
                    const finalThickness = baseThickness + musicThickness;
                    
                    ctx.strokeStyle = trailColor + 'EE'; // More opaque for visibility
                    ctx.lineWidth = finalThickness;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    
                    const customGlow = (bot.tailGlow || 30) / 100;
                    const glowIntensity = customGlow * (1 + musicIntensity * 0.5);
                    ctx.shadowColor = trailColor;
                    ctx.shadowBlur = 15 * glowIntensity;
                    
                    // Draw tail with single pass for performance
                    ctx.beginPath();
                    for (let i = 0; i < bot.tailSegments.length; i++) {
                        const segment = bot.tailSegments[i];
                        if (i === 0) {
                            ctx.moveTo(segment.x, segment.y);
                        } else {
                            ctx.lineTo(segment.x, segment.y);
                        }
                    }
                    ctx.stroke();
                    
                    ctx.restore();
                }
                
                // Render bot body
                ctx.save();
                ctx.translate(bot.x, bot.y);
                ctx.rotate(bot.angle);
                
                // Use custom colors if available, otherwise defaults
                let botColor, accentColor;
                
                if (bot.type === 'ally' && bot.bodyColor && bot.accentColor) {
                    // Use customized ally colors
                    botColor = bot.bodyColor;
                    accentColor = bot.accentColor;
                } else {
                    // Default colors for support bots or uncustomized allies
                    botColor = bot.type === 'ally' ? '#00ff88' : '#88ff44';
                    accentColor = bot.type === 'ally' ? '#00ffff' : '#aaff66';
                }
                
                // Override with special effects if active
                if (mods.tags.rainbow || (visualSettings.colorPulse && musicIntensity > 0.5)) {
                    const hue = (gameTime * 180 + bot.id * 60) % 360;
                    botColor = `hsl(${hue}, 80%, 60%)`;
                    accentColor = `hsl(${(hue + 120) % 360}, 80%, 70%)`;
                }
                
                ctx.fillStyle = botColor;
                ctx.strokeStyle = accentColor;
                ctx.lineWidth = bot.type === 'ally' ? 3 : 2;
                
                const glowIntensity = (bot.type === 'ally' ? 0.7 : 0.4) * (1 + musicIntensity * 0.3);
                ctx.shadowColor = accentColor;
                ctx.shadowBlur = (bot.type === 'ally' ? 20 : 12) * glowIntensity;
                
                // Draw bot based on shape
                drawBotShape(ctx, bot);
                
                ctx.fill();
                ctx.stroke();
                
                // Health bar (only show when damaged)
                if (bot.hp < bot.maxHp) {
                    ctx.restore();
                    const barWidth = bot.radius * (bot.type === 'ally' ? 2 : 1.5);
                    const barHeight = bot.type === 'ally' ? 4 : 3;
                    const barX = bot.x - barWidth / 2;
                    const barY = bot.y - bot.radius - (bot.type === 'ally' ? 10 : 8);
                    const healthPercent = bot.hp / bot.maxHp;
                    
                    // Use the bot's custom colors for health bar too
                    const healthBarColor = (bot.type === 'ally' && bot.bodyColor) ? bot.bodyColor : (bot.type === 'ally' ? '#00ff88' : '#88ff44');
                    ctx.fillStyle = healthBarColor;
                    ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);
                    
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(barX, barY, barWidth, barHeight);
                } else {
                    ctx.restore();
                }
                
                // Ally name label (follows ally)
                if (bot.type === 'ally' && showAllyNames) {
                    ctx.save();
                    ctx.font = '10px monospace';
                    ctx.fillStyle = bot.titleColor || '#ff4444';
                    ctx.textAlign = 'center';
                    const labelIndex = (bot.allyIndex !== undefined ? bot.allyIndex + 1 : 1);
                    ctx.fillText(`Ally ${labelIndex}`, bot.x, bot.y - bot.radius - 16);
                    ctx.restore();
                }
            });
        }
        
        function drawBotShape(ctx, bot) {
            const shape = bot.shape || 'triangle';
            const r = bot.radius;
            
            ctx.beginPath();
            switch (shape) {
                case 'triangle':
                    ctx.moveTo(r * 0.8, 0);
                    ctx.lineTo(-r * 0.6, r * 0.5);
                    ctx.lineTo(-r * 0.3, 0);
                    ctx.lineTo(-r * 0.6, -r * 0.5);
                    ctx.closePath();
                    break;
                case 'diamond':
                    ctx.moveTo(r, 0);
                    ctx.lineTo(0, r * 0.7);
                    ctx.lineTo(-r * 0.8, 0);
                    ctx.lineTo(0, -r * 0.7);
                    ctx.closePath();
                    break;
                case 'arrow':
                    ctx.moveTo(r, 0);
                    ctx.lineTo(-r * 0.5, r * 0.4);
                    ctx.lineTo(-r * 0.3, r * 0.2);
                    ctx.lineTo(-r * 0.8, r * 0.3);
                    ctx.lineTo(-r * 0.8, -r * 0.3);
                    ctx.lineTo(-r * 0.3, -r * 0.2);
                    ctx.lineTo(-r * 0.5, -r * 0.4);
                    ctx.closePath();
                    break;
                case 'star':
                    const spikes = 5;
                    const outerRadius = r;
                    const innerRadius = r * 0.5;
                    for (let i = 0; i < spikes * 2; i++) {
                        const radius = i % 2 === 0 ? outerRadius : innerRadius;
                        const angle = (i * Math.PI) / spikes;
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(angle) * radius;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    break;
                default:
                    // Default triangle
                    ctx.moveTo(r * 0.8, 0);
                    ctx.lineTo(-r * 0.6, r * 0.5);
                    ctx.lineTo(-r * 0.3, 0);
                    ctx.lineTo(-r * 0.6, -r * 0.5);
                    ctx.closePath();
                    break;
            }
        }
        
        function renderPlayer(mods, musicIntensity = 0) {
            if (!player) return; // Safety check
            
            // Render tail - much brighter and more reactive
            if (tailSegments.length > 1) {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                
                let trailColor = tailCustomization.color;
                if (mods.tags.rainbow || (visualSettings.colorPulse && musicIntensity > 0.3)) {
                    const hue = (gameTime * 200 + musicIntensity * 360) % 360;
                    trailColor = `hsl(${hue}, 90%, 70%)`;
                } else if (mods.tags.toxic) {
                    trailColor = '#00ff00';
                } else if (mods.tags.vaporwave) {
                    trailColor = '#ff00ff';
                } else if (selectedInhibitors.length > 0) {
                    const inhibitor = GAME_CONFIG.INHIBITORS.find(inh => inh.id === selectedInhibitors[0]);
                    if (inhibitor) {
                        const musicMod = visualSettings.colorPulse ? musicIntensity * 60 : 0;
                        trailColor = `hsl(${inhibitor.hue + musicMod}, 90%, 70%)`;
                    }
                }
                
                // Customizable tail thickness
                const baseThickness = tailCustomization.width + mods.effects.glow * 2;
                const musicThickness = visualSettings.backgroundReact ? musicIntensity * 2 : 0;
                const finalThickness = baseThickness + musicThickness;
                
                ctx.strokeStyle = trailColor + 'EE'; // Much more opaque
                ctx.lineWidth = finalThickness;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                // Customizable glow effect
                const customGlow = tailCustomization.glow / 100;
                const glowIntensity = (mods.effects.glow + customGlow) * (1 + musicIntensity);
                ctx.shadowColor = trailColor;
                ctx.shadowBlur = 30 * glowIntensity;
                
                // Draw multiple passes for extra brightness
                for (let pass = 0; pass < 2; pass++) {
                    ctx.beginPath();
                    for (let i = 0; i < tailSegments.length; i++) {
                        const segment = tailSegments[i];
                        
                        // Add music-reactive wobble to tail
                        let x = segment.x;
                        let y = segment.y;
                        if (visualSettings.trippyEffects && musicIntensity > 0.4) {
                            const wobble = Math.sin(gameTime * 8 + i * 0.3) * musicIntensity * 3;
                            x += wobble;
                            y += Math.cos(gameTime * 9 + i * 0.3) * musicIntensity * 3;
                        }
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                    
                    // Second pass is dimmer and wider for glow
                    if (pass === 0) {
                        ctx.strokeStyle = trailColor + '99';
                        ctx.lineWidth = finalThickness * 1.8;
                        ctx.shadowBlur = 50 * glowIntensity;
                    }
                }
                
                ctx.restore();
            }
            
            // Render charging effect around player
            if (secondaryCharging && secondaryChargeTime > 0) {
                const chargeIntensity = secondaryChargeTime / maxSecondaryCharge;
                const pulseIntensity = Math.sin(gameTime * 15) * 0.5 + 0.5;
                
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';
                
                // Charging ring around player
                const ringRadius = player.radius + 10 + chargeIntensity * 15;
                const ringColor = chargeIntensity > 0.7 ? '#ff0080' : '#ffff00';
                
                ctx.strokeStyle = ringColor;
                ctx.lineWidth = 3 + chargeIntensity * 3;
                ctx.shadowColor = ringColor;
                ctx.shadowBlur = 20 + chargeIntensity * 20;
                ctx.globalAlpha = 0.7 + pulseIntensity * 0.3;
                
                ctx.beginPath();
                ctx.arc(player.x, player.y, ringRadius, 0, Math.PI * 2);
                ctx.stroke();
                
                // Inner charging ring when highly charged
                if (chargeIntensity > 0.5) {
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 15;
                    ctx.globalAlpha = chargeIntensity * pulseIntensity;
                    
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.radius + 5, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                ctx.restore();
            }
            
            // Render player ship
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(player.angle);
            
            // Invulnerability flashing
            if (player.invulnerable > 0 && Math.floor(gameTime * 12) % 2) {
                ctx.globalAlpha = 0.5;
            }
            
            // Glitch effect
            if (mods.tags.glitchy && Math.random() < 0.1) {
                ctx.translate((Math.random() - 0.5) * 6, (Math.random() - 0.5) * 6);
            }
            
            // Ship colors from customization and inhibitors
            let shipColor = shipCustomization.bodyColor || '#ffffff';
            let accentColor = shipCustomization.accentColor || '#00f0ff';
            
            // Apply inhibitor color modifications
            if (selectedInhibitors.length > 0) {
                const inhibitor = GAME_CONFIG.INHIBITORS.find(inh => inh.id === selectedInhibitors[0]);
                if (inhibitor) {
                    const musicMod = visualSettings.colorPulse ? musicIntensity * 60 : 0;
                    shipColor = `hsl(${inhibitor.hue + musicMod}, 80%, 70%)`;
                    accentColor = `hsl(${(inhibitor.hue + 180 + musicMod) % 360}, 80%, 60%)`;
                }
            }
            
            if (mods.tags.rainbow || (visualSettings.colorPulse && musicIntensity > 0.5)) {
                const hue1 = (gameTime * 200 + musicIntensity * 360) % 360;
                const hue2 = (hue1 + 180) % 360;
                shipColor = `hsl(${hue1}, 90%, 70%)`;
                accentColor = `hsl(${hue2}, 90%, 60%)`;
            }
            
            ctx.fillStyle = shipColor;
            ctx.strokeStyle = accentColor;
            ctx.lineWidth = 3;
            
            const glowIntensity = (mods.effects.glow + 0.3) * (1 + musicIntensity * 0.5);
            ctx.shadowColor = accentColor;
            ctx.shadowBlur = 25 * glowIntensity;
            
            // Ship geometry based on customization
            ctx.beginPath();
            switch (shipCustomization.shape) {
                case 'triangle':
                    ctx.moveTo(player.radius, 0);
                    ctx.lineTo(-player.radius * 0.7, player.radius * 0.6);
                    ctx.lineTo(-player.radius * 0.4, 0);
                    ctx.lineTo(-player.radius * 0.7, -player.radius * 0.6);
                    ctx.closePath();
                    break;
                case 'diamond':
                    ctx.moveTo(player.radius, 0);
                    ctx.lineTo(0, player.radius * 0.7);
                    ctx.lineTo(-player.radius * 0.8, 0);
                    ctx.lineTo(0, -player.radius * 0.7);
                    ctx.closePath();
                    break;
                case 'arrow':
                    ctx.moveTo(player.radius, 0);
                    ctx.lineTo(-player.radius * 0.5, player.radius * 0.4);
                    ctx.lineTo(-player.radius * 0.3, player.radius * 0.2);
                    ctx.lineTo(-player.radius * 0.8, player.radius * 0.3);
                    ctx.lineTo(-player.radius * 0.8, -player.radius * 0.3);
                    ctx.lineTo(-player.radius * 0.3, -player.radius * 0.2);
                    ctx.lineTo(-player.radius * 0.5, -player.radius * 0.4);
                    ctx.closePath();
                    break;
                case 'star':
                    const spikes = 5;
                    const outerRadius = player.radius;
                    const innerRadius = player.radius * 0.5;
                    for (let i = 0; i < spikes * 2; i++) {
                        const radius = i % 2 === 0 ? outerRadius : innerRadius;
                        const angle = (i * Math.PI) / spikes;
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(angle) * radius;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    break;
                case 'circle':
                default:
                    ctx.arc(0, 0, player.radius, 0, Math.PI * 2);
                    break;
            }
            
            ctx.fill();
            ctx.stroke();
            
            ctx.restore();
        }

        function renderBullets(musicIntensity = 0) {
            bullets.forEach(bullet => {
                ctx.save();
                
                ctx.fillStyle = bullet.color || '#00f0ff';
                
                // Only add glow for secondary bullets or when music is intense
                if (bullet.secondary || bullet.glowing || musicIntensity > 0.4) {
                    ctx.shadowColor = bullet.color || '#00f0ff';
                    const glowSize = bullet.secondary ? 25 : 10;
                    ctx.shadowBlur = glowSize + (musicIntensity * 10);
                }
                
                if (bullet.enemyBullet) {
                    // Square for enemy bullets
                    ctx.fillRect(bullet.x - bullet.radius, bullet.y - bullet.radius, 
                                bullet.radius * 2, bullet.radius * 2);
                } else {
                    // Player bullets with different shapes
                    ctx.beginPath();
                    
                    if (bullet.secondary) {
                        // Large glowing circle for secondary weapon
                        ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
                        ctx.fill();
                        // Add inner bright core
                        ctx.shadowBlur = 5;
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(bullet.x, bullet.y, bullet.radius * 0.4, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (bullet.ammoType === 'piercing') {
                        // Diamond shape for piercing
                        ctx.moveTo(bullet.x, bullet.y - bullet.radius);
                        ctx.lineTo(bullet.x + bullet.radius * 0.7, bullet.y);
                        ctx.lineTo(bullet.x, bullet.y + bullet.radius);
                        ctx.lineTo(bullet.x - bullet.radius * 0.7, bullet.y);
                        ctx.closePath();
                        ctx.fill();
                    } else if (bullet.ammoType === 'explosive') {
                        // Hexagon for explosive
                        for (let i = 0; i < 6; i++) {
                            const angle = (i * Math.PI) / 3;
                            const x = bullet.x + Math.cos(angle) * bullet.radius;
                            const y = bullet.y + Math.sin(angle) * bullet.radius;
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.closePath();
                        ctx.fill();
                    } else if (bullet.ammoType === 'spread') {
                        // Triangle for spread
                        ctx.moveTo(bullet.x, bullet.y - bullet.radius);
                        ctx.lineTo(bullet.x + bullet.radius * 0.8, bullet.y + bullet.radius * 0.6);
                        ctx.lineTo(bullet.x - bullet.radius * 0.8, bullet.y + bullet.radius * 0.6);
                        ctx.closePath();
                        ctx.fill();
                    } else {
                        // Circle for standard
                        ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                ctx.restore();
            });
        }

        function renderEnemies(musicIntensity = 0) {
            enemies.forEach(enemy => {
                ctx.save();
                
                // Special effects for charging bomber
                if (enemy.type === 'bomber' && enemy.state === 'charge') {
                    const pulseIntensity = Math.sin(gameTime * 10) * 0.5 + 0.5;
                    ctx.shadowColor = '#ff0000';
                    ctx.shadowBlur = 20 + pulseIntensity * 10;
                    
                    // Warning circle
                    ctx.strokeStyle = `rgba(255, 0, 0, ${0.5 + pulseIntensity * 0.5})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, enemy.radius * 3, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                ctx.strokeStyle = enemy.color;
                ctx.fillStyle = enemy.color + '40';
                ctx.lineWidth = 2 + musicIntensity * 2;
                ctx.shadowColor = enemy.color;
                const musicGlow = visualSettings.colorPulse ? musicIntensity * 15 : 0;
                ctx.shadowBlur = 10 + musicGlow;
                
                // Different shapes based on type
                if (enemy.type === 'orbiter') {
                    ctx.beginPath();
                    ctx.rect(enemy.x - enemy.radius, enemy.y - enemy.radius, 
                            enemy.radius * 2, enemy.radius * 2);
                } else if (enemy.type === 'shooter' || enemy.type === 'strafe') {
                    ctx.beginPath();
                    ctx.moveTo(enemy.x, enemy.y - enemy.radius);
                    ctx.lineTo(enemy.x - enemy.radius, enemy.y + enemy.radius);
                    ctx.lineTo(enemy.x + enemy.radius, enemy.y + enemy.radius);
                    ctx.closePath();
                } else if (enemy.type === 'bomber') {
                    // Diamond shape for bombers
                    ctx.beginPath();
                    ctx.moveTo(enemy.x, enemy.y - enemy.radius);
                    ctx.lineTo(enemy.x + enemy.radius, enemy.y);
                    ctx.lineTo(enemy.x, enemy.y + enemy.radius);
                    ctx.lineTo(enemy.x - enemy.radius, enemy.y);
                    ctx.closePath();
                } else if (enemy.type === 'sniper') {
                    // Star shape for snipers
                    const spikes = 5;
                    const outerRadius = enemy.radius;
                    const innerRadius = enemy.radius * 0.5;
                    
                    ctx.beginPath();
                    for (let i = 0; i < spikes * 2; i++) {
                        const radius = i % 2 === 0 ? outerRadius : innerRadius;
                        const angle = (i * Math.PI) / spikes;
                        const x = enemy.x + Math.cos(angle) * radius;
                        const y = enemy.y + Math.sin(angle) * radius;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                } else {
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
                }
                
                ctx.fill();
                ctx.stroke();
                
                // Health bar
                if (enemy.hp < enemy.maxHp) {
                    const barWidth = enemy.radius * 2;
                    const barHeight = 4;
                    const barX = enemy.x - barWidth / 2;
                    const barY = enemy.y - enemy.radius - 10;
                    const healthPercent = enemy.hp / enemy.maxHp;
                    
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);
                    
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(barX, barY, barWidth, barHeight);
                }
                
                // Charge timer for bomber
                if (enemy.type === 'bomber' && enemy.state === 'charge') {
                    const progress = 1 - (enemy.chargeTimer / 1.0);
                    const barY = enemy.y + enemy.radius + 15;
                    
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(enemy.x - enemy.radius, barY, enemy.radius * 2 * progress, 6);
                    
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(enemy.x - enemy.radius, barY, enemy.radius * 2, 6);
                }
                
                ctx.restore();
            });
        }

        function renderParticles() {
            if (!graphicsSettings.visualEffects || particles.length === 0) return;
            
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            
            // Simple particle rendering without complex batching
            particles.forEach(particle => {
                if (particle.alpha <= 0) return;
                
                ctx.globalAlpha = particle.alpha;
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                ctx.fill();
            });
            
            ctx.restore();
        }

        function renderMusicOverlay(intensity) {
            if (!visualSettings.colorPulse) return;
            
            const gradient = ctx.createRadialGradient(
                GAME_CONFIG.CANVAS_WIDTH/2, GAME_CONFIG.CANVAS_HEIGHT/2, 0,
                GAME_CONFIG.CANVAS_WIDTH/2, GAME_CONFIG.CANVAS_HEIGHT/2, 
                Math.max(GAME_CONFIG.CANVAS_WIDTH, GAME_CONFIG.CANVAS_HEIGHT)
            );
            
            const hue = (gameTime * 50 + intensity * 180) % 360;
            const color = `hsla(${hue}, 80%, 60%, ${intensity * 0.15})`;
            
            gradient.addColorStop(0, 'transparent');
            gradient.addColorStop(0.6, 'transparent');
            gradient.addColorStop(1, color);
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, GAME_CONFIG.CANVAS_WIDTH, GAME_CONFIG.CANVAS_HEIGHT);
        }
        
        function renderCursor() {
            if (!cursorSettings.enabled) return;
            
            ctx.save();
            ctx.globalAlpha = cursorSettings.opacity;
            ctx.strokeStyle = cursorSettings.color;
            ctx.fillStyle = cursorSettings.color;
            ctx.lineWidth = 2;
            
            const size = cursorSettings.size;
            const halfSize = size / 2;
            
            ctx.beginPath();
            switch (cursorSettings.type) {
                case 'cross':
                    // Cross hair
                    ctx.moveTo(mouse.x - halfSize, mouse.y);
                    ctx.lineTo(mouse.x + halfSize, mouse.y);
                    ctx.moveTo(mouse.x, mouse.y - halfSize);
                    ctx.lineTo(mouse.x, mouse.y + halfSize);
                    // Center dot
                    ctx.moveTo(mouse.x + 2, mouse.y);
                    ctx.arc(mouse.x, mouse.y, 2, 0, Math.PI * 2);
                    break;
                case 'dot':
                    // Simple dot
                    ctx.arc(mouse.x, mouse.y, size / 4, 0, Math.PI * 2);
                    break;
                case 'circle':
                    // Circle
                    ctx.arc(mouse.x, mouse.y, halfSize, 0, Math.PI * 2);
                    break;
                case 'target':
                    // Target reticle
                    ctx.arc(mouse.x, mouse.y, halfSize, 0, Math.PI * 2);
                    ctx.moveTo(mouse.x - halfSize - 5, mouse.y);
                    ctx.lineTo(mouse.x - halfSize + 2, mouse.y);
                    ctx.moveTo(mouse.x + halfSize - 2, mouse.y);
                    ctx.lineTo(mouse.x + halfSize + 5, mouse.y);
                    ctx.moveTo(mouse.x, mouse.y - halfSize - 5);
                    ctx.lineTo(mouse.x, mouse.y - halfSize + 2);
                    ctx.moveTo(mouse.x, mouse.y + halfSize - 2);
                    ctx.lineTo(mouse.x, mouse.y + halfSize + 5);
                    break;
            }
            
            if (cursorSettings.type === 'dot') {
                ctx.fill();
            } else {
                ctx.stroke();
            }
            
            ctx.restore();
        }

        // Game loop with simplified timing
        function gameLoop(currentTime) {
            const deltaTime = Math.min((currentTime - lastTime) / 1000, 1/30);
            lastTime = currentTime;
            gameTime = currentTime / 1000;
            frameCount++;
            
            // Reset frameCount periodically to avoid overflow
            if (frameCount > 10000) frameCount = 0;

            // Update total time playing for learning state
            playerLearningState.timePlaying += deltaTime;
            
            // Periodic saving of learning state
            if (gameState === 'playing' && gameTime - lastSaveTime > SAVE_INTERVAL) {
                saveLearningState();
                lastSaveTime = gameTime;
            }

            if (gameState === 'playing' && player !== null) {
                // Update adaptive difficulty offset based on player learning
                const aggressionInfluence = (playerLearningState.playerAggression - 0.5) * 0.5; // Scale -0.25 to 0.25
                const accuracyInfluence = (playerLearningState.playerAccuracy - 0.5) * 0.5;   // Scale -0.25 to 0.25
                const evasivenessInfluence = (playerLearningState.playerEvasiveness - 0.5) * 0.5; // Scale -0.25 to 0.25

                // Combine influences. Clamp to prevent extreme values.
                let newAdaptiveOffset = aggressionInfluence + accuracyInfluence + evasivenessInfluence;
                newAdaptiveOffset = Utils.clamp(newAdaptiveOffset, -0.5, 0.5); // Max -0.5 to +0.5 difficulty adjustment

                // Smoothly lerp towards the new offset
                playerLearningState.adaptiveDifficultyOffset = Utils.lerp(
                    playerLearningState.adaptiveDifficultyOffset,
                    newAdaptiveOffset,
                    0.0005 // Slow adaptation
                );
                
                // Update screen shake
                updateScreenShake(deltaTime);
                
                // Update game objects
                updatePlayer(deltaTime);
                updateBullets(deltaTime);
                updateEnemies(deltaTime);
                updateParticles(deltaTime);
                updatePowerUps(deltaTime);
                
                // Handle systems 
                updateWaveSystem(deltaTime);
                handleCollisions();
                handleSpawning(deltaTime);
                
                // Check game over
                if (player.hp <= 0) {
                    endGame();
                }
                
                // Update HUD occasionally
                if (Math.floor(gameTime * 10) % 2 === 0) {
                    updateHUD();
                }
                
                // Update HUD auto-hide system
                updateHUDAutoHide(deltaTime);
            }
            
            // Always update background stars (even in menus)
            const musicIntensity = getMusicIntensity();
            updateBackgroundStars(musicIntensity);
            
            // Always render (except when paused)
            if (gameState !== 'paused') {
                render();
            }
            
            requestAnimationFrame(gameLoop);
        }

        function updateBullets(deltaTime) {
            bullets = bullets.filter(bullet => {
                bullet.x += bullet.vx * deltaTime;
                bullet.y += bullet.vy * deltaTime;
                bullet.life -= deltaTime;
                
                // Bullet bouncing off walls
                let bounced = false;
                if (bullet.bounces > 0) {
                    if (bullet.x <= 0 || bullet.x >= GAME_CONFIG.CANVAS_WIDTH) {
                        bullet.vx = -bullet.vx;
                        bullet.x = Utils.clamp(bullet.x, 0, GAME_CONFIG.CANVAS_WIDTH);
                        bullet.bounces--;
                        bounced = true;
                    }
                    if (bullet.y <= 0 || bullet.y >= GAME_CONFIG.CANVAS_HEIGHT) {
                        bullet.vy = -bullet.vy;
                        bullet.y = Utils.clamp(bullet.y, 0, GAME_CONFIG.CANVAS_HEIGHT);
                        bullet.bounces--;
                        bounced = true;
                    }
                    
                    if (bounced && sfxVolume > 0) {
                        playSFX('pickup');
                    }
                }
                
                // Remove bullets that are out of bounds or expired
                const outOfBounds = bullet.x < -100 || bullet.x > GAME_CONFIG.CANVAS_WIDTH + 100 ||
                                   bullet.y < -100 || bullet.y > GAME_CONFIG.CANVAS_HEIGHT + 100;
                
                if (bullet.life <= 0 || (outOfBounds && bullet.bounces <= 0)) {
                    // Only create death particles for secondary bullets
                    if (bullet.secondary && bullet.life <= 0) {
                        for (let i = 0; i < 3; i++) {
                            const angle = Utils.rand(0, Math.PI * 2);
                            const speed = Utils.rand(30, 60);
                            particles.push({
                                x: bullet.x,
                                y: bullet.y,
                                vx: Math.cos(angle) * speed,
                                vy: Math.sin(angle) * speed,
                                radius: 2,
                                color: bullet.color,
                                life: 0.4,
                                maxLife: 0.4,
                                alpha: 1,
                                active: true
                            });
                        }
                    }
                    return false;
                }
                
                return true;
            });
        }

        function spawnAlly(initialAllyIndex = -1) {
            const angle = Utils.rand(0, Math.PI * 2);
            const distance = Utils.rand(100, 150);
            
            // Determine the allyIndex. If provided, use it. Otherwise, find the next available index.
            let allyCount = friendlyBots.filter(bot => bot.type === 'ally').length;
            let currentAllyIndex = initialAllyIndex !== -1 ? initialAllyIndex : allyCount;

            // Ensure we don't exceed allyConfig.count when spawning new ones.
            if (friendlyBots.filter(bot => bot.type === 'ally').length >= allyConfig.count && initialAllyIndex === -1) {
                return; // Don't spawn if already at max count and not respawning a specific index
            }
            
            // Apply multipliers from customization
            const baseHp = 80;
            const baseSpeed = 140;
            const baseDamage = 1.2;
            const baseRadius = 14;
            
            const ally = {
                id: Date.now() + Math.random(),
                type: 'ally',
                name: `Ally ${currentAllyIndex + 1}`, // Assign a name based on allyIndex
                x: player.x + Math.cos(angle) * distance,
                y: player.y + Math.sin(angle) * distance,
                vx: 0, vy: 0,
                angle: 0,
                radius: allyConfig.sizes[currentAllyIndex % allyConfig.sizes.length] || baseRadius,
                hp: Math.floor(baseHp * allyMultipliers.hp),
                maxHp: Math.floor(baseHp * allyMultipliers.hp),
                speed: baseSpeed * allyMultipliers.speed,
                fireRate: 6,
                damage: baseDamage * allyMultipliers.damage,
                fireTimer: Utils.rand(0, 1),
                targetEnemy: null,
                avoidanceTimer: 0,
                shape: allyConfig.shapes[currentAllyIndex % allyConfig.shapes.length] || 'triangle',
                behavior: allyConfig.behavior,
                lastSeparationMove: 0,
                allyIndex: currentAllyIndex, // Track which ally this is
                // Add custom colors for this specific ally
                bodyColor: allyConfig.bodyColors[currentAllyIndex % allyConfig.bodyColors.length] || '#00ff88',
                accentColor: allyConfig.accentColors[currentAllyIndex % allyConfig.accentColors.length] || '#00ffff',
                titleColor: allyConfig.titleColors[currentAllyIndex % allyConfig.titleColors.length] || '#ff4444',
                // Ally tail settings
                tailEnabled: allyConfig.tailEnabled[currentAllyIndex % allyConfig.tailEnabled.length] || false,
                tailColor: allyConfig.tailColors[currentAllyIndex % allyConfig.tailColors.length] || '#00ffff',
                tailWidth: allyConfig.tailWidths[currentAllyIndex % allyConfig.tailWidths.length] || 2,
                tailGlow: allyConfig.tailGlows[currentAllyIndex % allyConfig.tailGlows.length] || 30,
                tailSegments: [], // Initialize empty tail
                score: 0 // Initialize ally score
            };
            
            // Position allies: first 4 start at the corners, extras along edges
            const padding = 10;
            if (ally.allyIndex < 4) {
                const corners = [
                    { x: ally.radius + padding, y: ally.radius + padding }, // top-left
                    { x: GAME_CONFIG.CANVAS_WIDTH - ally.radius - padding, y: ally.radius + padding }, // top-right
                    { x: GAME_CONFIG.CANVAS_WIDTH - ally.radius - padding, y: GAME_CONFIG.CANVAS_HEIGHT - ally.radius - padding }, // bottom-right
                    { x: ally.radius + padding, y: GAME_CONFIG.CANVAS_HEIGHT - ally.radius - padding } // bottom-left
                ];
                ally.x = corners[ally.allyIndex].x;
                ally.y = corners[ally.allyIndex].y;
            } else {
                const side = ally.allyIndex % 4; // distribute along edges
                const t = Math.random();
                const minX = ally.radius + padding;
                const maxX = GAME_CONFIG.CANVAS_WIDTH - ally.radius - padding;
                const minY = ally.radius + padding;
                const maxY = GAME_CONFIG.CANVAS_HEIGHT - ally.radius - padding;
                if (side === 0) { // top
                    ally.x = minX + t * (maxX - minX);
                    ally.y = minY;
                } else if (side === 1) { // right
                    ally.x = maxX;
                    ally.y = minY + t * (maxY - minY);
                } else if (side === 2) { // bottom
                    ally.x = minX + t * (maxX - minX);
                    ally.y = maxY;
                } else { // left
                    ally.x = minX;
                    ally.y = minY + t * (maxY - minY);
                }
            }

            // Keep allies on screen
            ally.x = Utils.clamp(ally.x, ally.radius, GAME_CONFIG.CANVAS_WIDTH - ally.radius);
            ally.y = Utils.clamp(ally.y, ally.radius, GAME_CONFIG.CANVAS_HEIGHT - ally.radius);
            
            friendlyBots.push(ally);
            friendlyBots.sort((a, b) => a.allyIndex - b.allyIndex); // Keep allies sorted by index
        }
        
        function spawnSupportBot() {
            const angle = Utils.rand(0, Math.PI * 2);
            const distance = Utils.rand(60, 100);
            
            const bot = {
                id: Date.now() + Math.random(),
                type: 'support',
                name: `Support Bot ${friendlyBots.filter(b => b.type === 'support').length + 1}`, // Assign a name
                x: player.x + Math.cos(angle) * distance,
                y: player.y + Math.sin(angle) * distance,
                vx: 0, vy: 0,
                angle: 0,
                radius: 6, // Much smaller
                hp: 25,
                maxHp: 25,
                speed: 160,
                fireRate: 8, // Faster but weaker
                damage: 0.6,
                fireTimer: Utils.rand(0, 1),
                targetEnemy: null,
                avoidanceTimer: 0,
                shape: 'triangle',
                behavior: 'aggressive'
            };
            
            // Keep bots on screen
            bot.x = Utils.clamp(bot.x, bot.radius, GAME_CONFIG.CANVAS_WIDTH - bot.radius);
            bot.y = Utils.clamp(bot.y, bot.radius, GAME_CONFIG.CANVAS_HEIGHT - bot.radius);
            
            friendlyBots.push(bot);
        }
        
        function updateFriendlyBots(deltaTime, mods) {
            friendlyBots.forEach(bot => {
                bot.fireTimer = Math.max(0, bot.fireTimer - deltaTime);
                bot.avoidanceTimer = Math.max(0, bot.avoidanceTimer - deltaTime);
                bot.lastSeparationMove = Math.max(0, bot.lastSeparationMove - deltaTime);
                
                // Update ally tail if enabled
                if (bot.type === 'ally' && bot.tailEnabled) {
                    if (!bot.tailSegments) bot.tailSegments = [];
                    
                    const segmentSpacing = 8; // Slightly wider spacing for allies
                    const maxTailLength = 25; // Shorter tails for allies
                    
                    // Add new segment
                    const lastSegment = bot.tailSegments[bot.tailSegments.length - 1];
                    if (!lastSegment || Utils.distance(bot, lastSegment) >= segmentSpacing) {
                        bot.tailSegments.push({
                            x: bot.x,
                            y: bot.y,
                            time: gameTime
                        });
                    }
                    
                    // Limit tail length
                    while (bot.tailSegments.length > maxTailLength) {
                        bot.tailSegments.shift();
                    }
                }
                
                // Find nearest enemy
                let nearestEnemy = null;
                let nearestDistance = Infinity;
                enemies.forEach(enemy => {
                    const dist = Utils.distance(bot, enemy);
                    if (dist < nearestDistance) {
                        nearestDistance = dist;
                        nearestEnemy = enemy;
                    }
                });
                
                bot.targetEnemy = nearestEnemy;
                
                // Enhanced AI based on type and behavior
                updateBotAI(bot, deltaTime, nearestEnemy, nearestDistance);
                
                // Apply separation from other bots (stronger for allies)
                const separationForce = bot.type === 'ally' ? 60 : 30;
                friendlyBots.forEach(otherBot => {
                    if (otherBot === bot) return;
                    const dist = Utils.distance(bot, otherBot);
                    const minDistance = bot.type === 'ally' ? 50 : 25;
                    
                    if (dist < minDistance && bot.lastSeparationMove <= 0) {
                        const avoidAngle = Utils.angleTo(otherBot, bot);
                        const force = (minDistance - dist) / minDistance;
                        bot.x += Math.cos(avoidAngle) * force * separationForce * deltaTime;
                        bot.y += Math.sin(avoidAngle) * force * separationForce * deltaTime;
                        bot.lastSeparationMove = 0.1; // Prevent constant separation
                    }
                });
                
                // Keep on screen
                bot.x = Utils.clamp(bot.x, bot.radius, GAME_CONFIG.CANVAS_WIDTH - bot.radius);
                bot.y = Utils.clamp(bot.y, bot.radius, GAME_CONFIG.CANVAS_HEIGHT - bot.radius);
                
                // Update aim angle
                if (bot.targetEnemy) {
                    bot.angle = Utils.angleTo(bot, bot.targetEnemy);
                } else {
                    bot.angle = Math.atan2(bot.vy, bot.vx);
                }
            });
        }
        
        function updateBotAI(bot, deltaTime, nearestEnemy, nearestDistance) {
            let targetX = player.x;
            let targetY = player.y;
            
            // Base behavior influenced by player learning state
            let currentBehavior = bot.behavior;

            // Make allies more aggressive if player is passive, or more defensive if player is taking a lot of hits
            if (playerLearningState.playerAggression < 0.4 && currentBehavior !== 'aggressive') {
                currentBehavior = 'aggressive'; // Boost aggression if player is passive
            } else if (playerLearningState.playerEvasiveness < 0.4 && player.hp < player.maxHp * 0.5 && currentBehavior !== 'defensive') {
                currentBehavior = 'defensive'; // Be more defensive if player is vulnerable and not evasive
            } else if (playerLearningState.adaptiveDifficultyOffset > 0.2 && currentBehavior === 'defensive') {
                currentBehavior = 'balanced'; // If difficulty increases, allies can revert to balanced from defensive
            }


            const behaviorMultiplier = {
                'defensive': { engage: 120, flee: 80, followDistance: 60, speedMult: 0.8 },
                'balanced': { engage: 180, flee: 50, followDistance: 80, speedMult: 1.0 },
                'aggressive': { engage: 250, flee: 30, followDistance: 100, speedMult: 1.2 }
            };
            
            const behavior = behaviorMultiplier[currentBehavior] || behaviorMultiplier['balanced'];

            // Adjust speed based on adaptive difficulty
            let moveSpeed = bot.speed * behavior.speedMult * (1 + playerLearningState.adaptiveDifficultyOffset * 0.2); // Allies get faster if player performs well
            
            let nearestPowerUp = null;
            let nearestPowerUpDist = Infinity;

            powerUps.forEach(p => {
                if (!p.collected) {
                    const dist = Utils.distance(bot, p);
                    if (dist < nearestPowerUpDist) {
                        nearestPowerUp = p;
                        nearestPowerUpDist = dist;
                    }
                }
            });
            
            // AI decision logic:
            // If bot health is low, prioritize health packs.
            // Otherwise, go for any power-up if it's closer than the nearest enemy.
            if (nearestPowerUp) {
                const isHealthLow = bot.hp / bot.maxHp < 0.5;
                const healthPowerUpNear = nearestPowerUp.type === 'health' && nearestPowerUpDist < 150; // Health power-up within 150px
                const powerUpCloserThanEnemy = nearestPowerUpDist < nearestDistance;
                
                if ( (isHealthLow && healthPowerUpNear) || (powerUpCloserThanEnemy && nearestPowerUpDist < 100) ) { // Prioritize power-ups
                    targetX = nearestPowerUp.x;
                    targetY = nearestPowerUp.y;
                    moveSpeed = bot.speed * 1.2; // Move faster to pick up
                    
                    // If focusing on power-up, don't shoot enemies
                    nearestEnemy = null; 
                    nearestDistance = Infinity;
                }
            }

            if (nearestEnemy && nearestDistance < behavior.engage) {
                const optimalDistance = bot.type === 'ally' ? 120 : 80;
                
                if (nearestDistance > optimalDistance) {
                    // Move closer to enemy
                    targetX = nearestEnemy.x;
                    targetY = nearestEnemy.y;
                    moveSpeed *= (currentBehavior === 'aggressive' ? 1.3 : 1.0);
                } else if (nearestDistance < behavior.flee) {
                    // Back away from enemy
                    const fleeAngle = Utils.angleTo(nearestEnemy, bot);
                    targetX = bot.x + Math.cos(fleeAngle) * 80;
                    targetY = bot.y + Math.sin(fleeAngle) * 80;
                    moveSpeed *= 1.2;
                } else {
                    // Circle strafe
                    const perpAngle = Utils.angleTo(bot, nearestEnemy) + Math.PI / 2;
                    targetX = bot.x + Math.cos(perpAngle) * 40;
                    targetY = bot.y + Math.sin(perpAngle) * 40;
                    moveSpeed *= 0.9;
                }
                
                // Enhanced shooting based on type and player's accuracy
                const maxShootDistance = bot.type === 'ally' ? 220 : 160;
                let fireRateModifier = 1.0;
                if (playerLearningState.playerAggression > 0.6) { // If player is aggressive, allies fire faster
                    fireRateModifier *= 1.1;
                }
                if (playerLearningState.adaptiveDifficultyOffset > 0.1) { // If overall difficulty is up, allies fire faster
                    fireRateModifier *= 1.05;
                }

                if (bot.fireTimer <= 0 && nearestDistance < maxShootDistance) {
                    botShoot(bot, nearestEnemy);
                    bot.fireTimer = 1 / (bot.fireRate * fireRateModifier);
                }
            } else {
                // Follow player behavior
                const playerDistance = Utils.distance(bot, player);
                const followDistance = behavior.followDistance;
                
                if (playerDistance > followDistance + 20) {
                    targetX = player.x;
                    targetY = player.y;
                    moveSpeed *= (currentBehavior === 'defensive' ? 1.2 : 1.0);
                } else if (playerDistance < followDistance - 20) {
                    const awayAngle = Utils.angleTo(player, bot);
                    targetX = bot.x + Math.cos(awayAngle) * 30;
                    targetY = bot.y + Math.sin(awayAngle) * 30;
                    moveSpeed *= 0.7;
                }
            }
            
            // Move towards target
            const moveAngle = Math.atan2(targetY - bot.y, targetX - bot.x);
            bot.vx = Math.cos(moveAngle) * moveSpeed;
            bot.vy = Math.sin(moveAngle) * moveSpeed;
            
            bot.x += bot.vx * deltaTime;
            bot.y += bot.vy * deltaTime;
        }
        
        function botShoot(bot, target) {
            const bulletSpeed = 600;
            const predictiveMultiplier = 0.3;
            
            // Predictive aiming
            const timeToHit = Utils.distance(bot, target) / bulletSpeed;
            const predictedX = target.x + (target.vx || 0) * timeToHit * predictiveMultiplier;
            const predictedY = target.y + (target.vy || 0) * timeToHit * predictiveMultiplier;
            const aimAngle = Math.atan2(predictedY - bot.y, predictedX - bot.x);
            
            bullets.push({
                x: bot.x + Math.cos(aimAngle) * bot.radius,
                y: bot.y + Math.sin(aimAngle) * bot.radius,
                owner: bot, // Add this line to assign the bot as the bullet owner
                vx: Math.cos(aimAngle) * bulletSpeed,
                vy: Math.sin(aimAngle) * bulletSpeed,
                radius: 2,
                damage: bot.damage,
                life: 2.5,
                color: '#00ff88',
                glowing: false,
                bounces: 1,
                friendlyFire: false // Don't hurt other friendly units
            });
            
            playSFX('pickup');
        }
        
        function applyInhibitorEffects(deltaTime, mods) {
            // Shield regeneration
            if (mods.effects.shield > 0) {
                player.maxShield = mods.effects.shield;
                player.shield = Math.min(player.maxShield, player.shield + 10 * deltaTime);
            }
            
            // Health regeneration
            if (mods.effects.regen > 0) {
                player.hp = Math.min(player.maxHp, player.hp + mods.effects.regen * deltaTime);
            }
            
            // Berserker mode
            if (mods.tags.berserker && player.hp / player.maxHp < 0.4) {
                player.fireRate *= 1.3;
                player.speed *= 1.2;
            }
        }
        
        function updateHUD() {
            document.getElementById('scoreDisplay').textContent = gameStats.score.toLocaleString();
            document.getElementById('personalScoreDisplay').textContent = gameStats.playerScore.toLocaleString();
            document.getElementById('teamScoreDisplay').textContent = gameStats.allyScore.toLocaleString();
            document.getElementById('waveDisplay').textContent = gameStats.wave;
            document.getElementById('levelDisplay').textContent = gameStats.level;
            document.getElementById('hpDisplay').textContent = gameStats.hp;
            document.getElementById('maxHpDisplay').textContent = gameStats.maxHp;
            document.getElementById('boostDisplay').textContent = gameStats.boostFuel;
            document.getElementById('enemyCountDisplay').textContent = enemies.length;
            updateAllyStatusInLegend(); // Update ally status in legend
        }

        function updateAllyStatusInLegend() {
            const allyStatusGrid = document.getElementById('allyStatus');
            if (!allyStatusGrid) return;

            allyStatusGrid.innerHTML = ''; // Clear previous status

            if (friendlyBots.length === 0) {
                allyStatusGrid.innerHTML = '<p style="text-align: center; color: #aaa;">No allies currently active.</p>';
                return;
            }

            friendlyBots.forEach(bot => {
                const allyDiv = document.createElement('div');
                allyDiv.className = 'ally-status-item';
                const botScore = bot.score || 0; // Use the actual score from the bot object
                
                allyDiv.innerHTML = `
                    <span style="color: ${bot.titleColor || '#FFF'};">${bot.name}</span>
                    <span>HP: ${Math.round(bot.hp)}/${Math.round(bot.maxHp)}</span>
                    <span>Score: ${botScore.toLocaleString()}</span>
                `;
                allyStatusGrid.appendChild(allyDiv);
            });
        }
        
        function updateHUDAutoHide(deltaTime) {
            if (!hudAutoHide) return;
            if (userToggledHud) {
                // User has manually controlled HUD - don't auto-hide
                return;
            }
            
            // Handle level show timer (takes priority)
            if (hudLevelShowTimer > 0) {
                hudLevelShowTimer -= deltaTime;
                if (hudLevelShowTimer <= 0) {
                    // Level show time expired, hide HUD again
                    hudVisible = false;
                    updateHUDVisibility();
                }
                return;
            }
            
            // Handle initial auto-hide timer
            if (hudAutoHideTimer > 0) {
                hudAutoHideTimer -= deltaTime;
                if (hudAutoHideTimer <= 0) {
                    // Time to auto-hide
                    hudVisible = false;
                    updateHUDVisibility();
                }
            }
        }
        
        function updateHUDVisibility() {
            const hud = document.getElementById('hud');
            const musicControls = document.getElementById('musicControls');
            const hudToggleIcon = document.getElementById('hudToggleIcon');
            
            if (hud) {
                hud.style.display = hudVisible ? 'block' : 'none';
            }
            // Keep music controls visible unless the user closed it
            if (musicControls) {
                musicControls.style.display = musicPlayerHidden ? 'none' : 'flex';
            }
            
            // New logic for two legends
            const gameLegendLeft = document.getElementById('gameLegendLeft');
            const gameLegendRight = document.getElementById('gameLegendRight');

            if (gameLegendLeft) {
                gameLegendLeft.style.display = hudVisible ? 'block' : 'none';
            }
            if (gameLegendRight) {
                gameLegendRight.style.display = hudVisible ? 'block' : 'none';
            }
            
            // Update toggle icon
            if (hudToggleIcon) {
                hudToggleIcon.textContent = hudVisible ? 'üëÅÔ∏è' : 'üôà';
                hudToggleIcon.title = hudVisible ? 'Hide HUD' : 'Show HUD';
            }

            // Reposition music controls when legend/HUD visibility changes
            repositionMusicControls();
        }

        // Keep music controls away from legend and inside game container
        function repositionMusicControls() {
            const musicControls = document.getElementById('musicControls');
            const container = document.getElementById('gameContainer');
            const gameLegend = document.getElementById('gameLegend');
            if (!musicControls || !container) return;
            if (musicPlayerHidden || musicControlsMoved) return; // Don't move if user dragged or closed
            
            // Compute top offset below legend if visible
            let top = 10;
            if (gameLegend && gameLegend.style.display !== 'none') {
                top = gameLegend.offsetTop + gameLegend.offsetHeight + 10;
            }
            musicControls.style.bottom = '10px';
            musicControls.style.left = '10px';
            musicControls.style.top = 'auto'; // Ensure top is not set
            musicControls.style.right = 'auto'; // Ensure right is not set
        }

        // UI Functions
        function showOverlay(overlayId) {
            document.querySelectorAll('.menu-overlay').forEach(overlay => {
                overlay.style.display = 'none';
            });
            document.getElementById(overlayId).style.display = 'flex';
        }

        function hideAllOverlays() {
            document.querySelectorAll('.menu-overlay').forEach(overlay => {
                overlay.style.display = 'none';
            });
        }

        function showMainMenu() {
            showOverlay('menuOverlay');
        }
        
        function startGame() {
            gameStartTime = performance.now();
            console.log('START GAME CLICKED!');
            console.log('Current game state:', gameState);
            
            gameState = 'playing';
            hideAllOverlays();
            document.getElementById('hud').style.display = 'block';
            
            // Reset game
            resetPlayer();
            canvas.style.cursor = 'none'; // Hide native cursor
            console.log('Player reset:', player);
            
            bullets = [];
            enemies = [];
            particles = [];
            powerUps = [];
            tailLength = 10; // Reset tail length
            gameStats = {
                score: 0,
                playerScore: 0,
                allyScore: 0,
                wave: 1,
                level: 1,
                enemiesKilled: 0,
                hp: player.maxHp,
                maxHp: player.maxHp,
                boostFuel: 100,
                shotsFired: 0,
                shotsHit: 0,
                deaths: 0
            };
            
            enemySpawnTimer = 1;
            
            // Reset HUD auto-hide system
            hudVisible = true;
            hudAutoHideTimer = hudAutoHide ? 7.5 : 0;
            hudLevelShowTimer = 0;
            userToggledHud = false;
            updateHUDVisibility();
            
            // Start music (no autoplay if blocked)
            if (youtubePlayer && youtubeReady) {
                try { youtubePlayer.playVideo(); } catch (e) { /* Autoplay may be blocked; user can press ‚ñ∂ */ }
            }
            
            // Show game legend
            document.getElementById('gameLegendLeft').style.display = 'block';
            document.getElementById('gameLegendRight').style.display = 'block';
            
            console.log('Game should be starting now! State:', gameState);
            console.log('Player position:', player ? `${player.x}, ${player.y}` : 'NULL');
            console.log('Canvas context:', ctx);
            
            showToast('Game started! Good luck!', 'success');
        }

        function pauseGame() {
            if (gameState === 'playing') {
                gameState = 'paused';
                canvas.style.cursor = 'default'; // Show native cursor
                showOverlay('pauseOverlay');
            } else if (gameState === 'paused') {
                gameState = 'playing';
                canvas.style.cursor = 'none'; // Hide native cursor
                hideAllOverlays();
                document.getElementById('hud').style.display = 'block';
            }
        }

        function endGame() {
            gameState = 'gameover';
            document.getElementById('hud').style.display = 'none';
            canvas.style.cursor = 'default'; // Show native cursor
            
            // Update game over display
            document.getElementById('finalScore').textContent = gameStats.score.toLocaleString();
            document.getElementById('finalWave').textContent = gameStats.wave;
            document.getElementById('finalLevel').textContent = gameStats.level;
            
            showOverlay('gameOverOverlay');
            
            // Save high score
            const playTimeInSeconds = (performance.now() - gameStartTime) / 1000;
            saveScoreToSupabase(playTimeInSeconds);
            saveLearningState(); // Save player learning state
        }

        async function saveScoreToSupabase(playTimeInSeconds) {
            try {
                const { data: { user } } = await supabaseClient.auth.getUser();

                if (!user) {
                    console.log('User not logged in. Score not saved.');
                    document.getElementById('newHighScore').style.display = 'block';
                    document.getElementById('newHighScore').textContent = "Login to save your score!";
                    return;
                }
                
                const accuracy = gameStats.shotsFired > 0 ? (gameStats.shotsHit / gameStats.shotsFired) * 100 : 0;
                gameStats.deaths = 1;

                const newScore = {
                    player_id: user.id,
                    score: Math.round(gameStats.score),
                    level: gameStats.level,
                    kills: gameStats.enemiesKilled,
                    deaths: gameStats.deaths,
                    accuracy: accuracy.toFixed(2),
                    match_id: 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                        var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                        return v.toString(16);
                    }),
                    difficulty: selectedDifficulty,
                    selected_inhibitors: selectedInhibitors,
                    num_allies: allyConfig.count,
                    wave: gameStats.wave,
                    play_time_seconds: Math.round(playTimeInSeconds),
                    ship_shape: shipCustomization.shape,
                    ship_body_color: shipCustomization.bodyColor,
                    ship_accent_color: shipCustomization.accentColor,
                    ammo_type: ammoCustomization.type,
                    ammo_size: ammoCustomization.size,
                    ammo_color: ammoCustomization.color,
                    tail_width: tailCustomization.width,
                    tail_glow: tailCustomization.glow,
                    tail_color: tailCustomization.color,
                    mouse_sensitivity: mouseSensitivity.toFixed(2), // Convert to fixed decimal places
                    secondary_fire_mode: secondaryHoldMode ? 'hold' : 'tap',
                    flashing_disabled: flashingEffectsDisabled
                };

                const { data, error } = await supabaseClient
                    .from('voidshooter_leaderboard')
                    .insert([newScore]);

                if (error) {
                    if (error.code === '23505') { // unique_violation
                        console.warn('Score for this match already submitted.');
                    } else {
                        console.error('Error saving score:', error);
                    }
                    document.getElementById('newHighScore').style.display = 'none';
                } else {
                    console.log('Score saved successfully');
                    document.getElementById('newHighScore').style.display = 'block';
                    document.getElementById('newHighScore').textContent = "üèÜ SCORE SAVED TO LEADERBOARD! üèÜ";
                }
            } catch (error) {
                console.error('Error in saveScoreToSupabase:', error);
                document.getElementById('newHighScore').style.display = 'none';
            }
        }
        
        async function loadLeaderboard(difficultyFilter = 'all', sortBy = 'score', sortOrder = 'desc') {
            const tableBody = document.getElementById('leaderboardTable');
            const noScoresMsg = document.getElementById('noScoresMessage');
            tableBody.innerHTML = '';
            noScoresMsg.style.display = 'block';

            // Update header visuals
            document.querySelectorAll('.sortable-header').forEach(header => {
                header.classList.remove('sorted-asc', 'sorted-desc');
                if (header.dataset.sort === sortBy) {
                    header.classList.add(sortOrder === 'asc' ? 'sorted-asc' : 'sorted-desc');
                }
            });

            try {
                let query = supabaseClient
                    .from('voidshooter_leaderboard')
                    .select(`
                        *,
                        profiles (
                            username
                        )
                    `)
                    .order(sortBy, { ascending: sortOrder === 'asc' })
                    .limit(20);

                if (difficultyFilter !== 'all') {
                    query = query.eq('difficulty', difficultyFilter);
                }

                const { data: scores, error } = await query;

                if (error) {
                    console.error('Error loading leaderboard:', error.message);
                    noScoresMsg.textContent = `Error loading leaderboard: ${error.message}.`;
                    return;
                }

                if (scores && scores.length > 0) {
                    noScoresMsg.style.display = 'none';
                    scores.forEach((score, index) => {
                        const row = document.createElement('tr');
                        row.style.borderBottom = '1px solid rgba(255,255,255,0.1)';
                        const username = score.profiles ? score.profiles.username : 'Anonymous';
                        
                        let rankStyle = '';
                        if (index === 0) rankStyle = 'color: #ffd700; font-weight: bold;'; // Gold
                        else if (index === 1) rankStyle = 'color: #c0c0c0; font-weight: bold;'; // Silver
                        else if (index === 2) rankStyle = 'color: #cd7f32; font-weight: bold;'; // Bronze
                        
                        row.innerHTML = `
                            <td style="padding: 8px; ${rankStyle}">${index + 1}</td>
                            <td style="padding: 8px; color: #00f0ff;">${username}</td>
                            <td style="padding: 8px; text-align: right; font-weight: bold;">${score.score.toLocaleString()}</td>
                            <td style="padding: 8px; text-align: center;">${score.level || '-'}</td>
                            <td style="padding: 8px; text-align: center;">${score.kills || '-'}</td>
                            <td style="padding: 8px; text-align: center;">${score.deaths || '-'}</td>
                            <td style="padding: 8px; text-align: center;">${score.accuracy ? score.accuracy.toFixed(2) + '%' : '-'}</td>
                            <td style="padding: 8px; text-align: center;">${score.wave || '-'}</td>
                            <td style="padding: 8px; text-align: center; text-transform: capitalize;">${score.difficulty || '-'}</td>
                            <td style="padding: 8px; text-align: center;">${score.num_allies || '0'}</td>
                            <td style="padding: 8px; text-align: center;">
                                <button class="menu-btn view-details-btn" data-score-id="${score.id}" style="padding: 5px 10px; font-size: 0.7rem;">View</button>
                            </td>
                        `;
                        tableBody.appendChild(row);
                    });
                    // Add event listeners for detail buttons
                    document.querySelectorAll('.view-details-btn').forEach(button => {
                        button.addEventListener('click', (event) => {
                            const scoreId = event.target.dataset.scoreId;
                            const scoreEntry = scores.find(s => s.id == scoreId); // Find the full score object
                            showLeaderboardDetail(scoreEntry);
                        });
                    });
                } else {
                    noScoresMsg.textContent = 'No scores yet for this difficulty. Play a game to be the first!';
                }

            } catch (error) {
                console.error('Failed to load leaderboard:', error.message || error);
                noScoresMsg.textContent = `Failed to load leaderboard: ${error.message || 'Unknown error'}.`;
            }
        }
        
        function clearLeaderboard() {
            // This button is now disabled as we don't want to allow clearing the central database.
            showToast('Clearing the leaderboard is disabled.', 'warning');
        }

        function showToast(message, type = 'info', duration = 3000) {
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                z-index: 10000;
                padding: 12px 20px;
                border-radius: 8px;
                font-weight: 500;
                animation: slideIn 0.3s ease;
                background: ${type === 'success' ? '#10b981' : type === 'warning' ? '#f59e0b' : '#3b82f6'};
                color: white;
            `;
            toast.textContent = message;
            
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.animation = 'slideIn 0.3s ease reverse';
                setTimeout(() => toast.remove(), 300);
            }, duration);
        }
        
        function showCredits() {
            const creditsHtml = `
                <div class="menu-overlay" id="creditsModal" style="display: flex; z-index: 15000;">
                    <div class="menu-title" style="font-size: 1.8rem;">üìú CREDITS</div>
                    
                    <div class="menu-section" style="max-width: 500px; text-align: center;">
                        <div style="background: rgba(0, 240, 255, 0.1); padding: 20px; border-radius: 10px; border: 1px solid rgba(0, 240, 255, 0.3); margin: 20px 0;">
                            <h3 style="color: #ffd700; margin: 0 0 15px 0; font-size: 1.3rem;">üéÆ GAME CREATOR</h3>
                            <p style="font-size: 1.1rem; color: #00f0ff; font-weight: bold; margin: 0;">Fu2</p>
                        </div>
                        
                        <div style="background: rgba(138, 43, 226, 0.1); padding: 15px; border-radius: 8px; border: 1px solid rgba(138, 43, 226, 0.3); margin: 15px 0;">
                            <h4 style="color: #8a2be6; margin: 0 0 10px 0;">üéµ MUSIC ATTRIBUTION</h4>
                            <p style="font-size: 0.9rem; margin: 5px 0; line-height: 1.4;">All music tracks are from underground artists<br>featured on our weekly Twitch rankings!</p>
                            <p style="font-size: 0.85rem; margin: 8px 0;">üì∫ Watch us live: 
                                <a href="https://www.twitch.tv/neverendever" target="_blank" rel="noopener" 
                                   style="color: #00f0ff; text-decoration: underline; font-weight: bold;">twitch.tv/neverendever</a>
                            </p>
                            <p style="font-size: 0.8rem; color: #888; margin: 5px 0;">Every Saturday at 7:00 PM EST</p>
                        </div>
                        
                        <div style="background: rgba(0, 255, 0, 0.1); padding: 15px; border-radius: 8px; border: 1px solid rgba(0, 255, 0, 0.3); margin: 15px 0;">
                            <h4 style="color: #00ff00; margin: 0 0 10px 0;">üìã PROJECT INFO</h4>
                            <p style="font-size: 0.85rem; margin: 3px 0;">‚Ä¢ Open source fan project</p>
                            <p style="font-size: 0.85rem; margin: 3px 0;">‚Ä¢ Educational & entertainment only</p>
                            <p style="font-size: 0.85rem; margin: 3px 0;">‚Ä¢ Built with HTML5 Canvas & JavaScript</p>
                            <p style="font-size: 0.85rem; margin: 3px 0;">‚Ä¢ No commercial use intended</p>
                        </div>
                        
                        <div style="margin-top: 20px;">
                            <p style="font-size: 0.8rem; color: #888; font-style: italic;">Thanks for playing! üöÄ</p>
                        </div>
                    </div>
                    
                    <div class="menu-section">
                        <button class="menu-btn" onclick="closeCredits()">BACK</button>
                    </div>
                </div>
            `;
            
            const modal = document.createElement('div');
            modal.innerHTML = creditsHtml;
            document.body.appendChild(modal.firstElementChild);
        }
        
        function closeCredits() {
            const modal = document.getElementById('creditsModal');
            if (modal) {
                modal.remove();
            }
        }
        
        function closeLegends() {
            document.getElementById('gameLegendLeft').style.display = 'none';
            document.getElementById('gameLegendRight').style.display = 'none';
        }

        // Initialize UI
        function showLeaderboardDetail(score) {
            const modal = document.getElementById('leaderboardDetailModal');
            const detailContent = document.getElementById('detailContent');
            if (!modal || !detailContent) return;

            // Format inhibitors
            const inhibitorsList = score.selected_inhibitors && score.selected_inhibitors.length > 0
                ? score.selected_inhibitors.map(i => `<li>${i}</li>`).join('')
                : '<li>None</li>';

            detailContent.innerHTML = `
                <p><strong>Player:</strong> ${score.profiles ? score.profiles.username : 'Anonymous'}</p>
                <p><strong>Score:</strong> ${score.score.toLocaleString()}</p>
                <p><strong>Level:</strong> ${score.level}</p>
                <p><strong>Wave:</strong> ${score.wave}</p>
                <p><strong>Difficulty:</strong> ${score.difficulty}</p>
                <p><strong>Kills:</strong> ${score.kills}</p>
                <p><strong>Deaths:</strong> ${score.deaths}</p>
                <p><strong>Accuracy:</strong> ${score.accuracy}%</p>
                <p><strong>Play Time:</strong> ${Math.round(score.play_time_seconds / 60)}m ${Math.round(score.play_time_seconds % 60)}s</p>
                <p><strong>Allies:</strong> ${score.num_allies}</p>
                <h4>Ship Customization</h4>
                <ul>
                    <li><strong>Shape:</strong> ${score.ship_shape}</li>
                    <li><strong>Body Color:</strong> ${score.ship_body_color}</li>
                    <li><strong>Accent Color:</strong> ${score.ship_accent_color}</li>
                </ul>
                <h4>Ammo Details</h4>
                <ul>
                    <li><strong>Type:</strong> ${score.ammo_type}</li>
                    <li><strong>Size:</strong> ${score.ammo_size}</li>
                    <li><strong>Color:</strong> ${score.ammo_color}</li>
                </ul>
                <h4>Tail Details</h4>
                <ul>
                    <li><strong>Width:</strong> ${score.tail_width}</li>
                    <li><strong>Glow:</strong> ${score.tail_glow}</li>
                    <li><strong>Color:</strong> ${score.tail_color}</li>
                </ul>
                <h4>Settings</h4>
                <ul>
                    <li><strong>Mouse Sensitivity:</strong> ${score.mouse_sensitivity}</li>
                    <li><strong>Secondary Fire:</strong> ${score.secondary_fire_mode === 'hold' ? 'Hold' : 'Tap'}</li>
                    <li><strong>Flashes Disabled:</strong> ${score.flashing_disabled ? 'Yes' : 'No'}</li>
                </ul>
                <h4>Inhibitors Used</h4>
                <ul>${inhibitorsList}</ul>
                <p style="font-size: 0.75rem; color: #888; margin-top: 10px;">Recorded: ${new Date(score.created_at).toLocaleString()}</p>
            `;

            modal.style.display = 'flex';
        }



        // Function to toggle fullscreen mode
        function toggleFullscreen() {
            const gameContainer = document.getElementById('gameContainer');
            if (!document.fullscreenElement) {
                if (gameContainer.requestFullscreen) {
                    gameContainer.requestFullscreen();
                } else if (gameContainer.mozRequestFullScreen) { // Firefox
                    gameContainer.mozRequestFullScreen();
                } else if (gameContainer.webkitRequestFullscreen) { // Chrome, Safari and Opera
                    gameContainer.webkitRequestFullscreen();
                } else if (gameContainer.msRequestFullscreen) { // IE/Edge
                    gameContainer.msRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.mozCancelFullScreen) { // Firefox
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) { // Chrome, Safari and Opera
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) { // IE/Edge
                    document.msExitFullscreen();
                }
            }
        }

        // Adjust canvas resolution automatically on fullscreen change
        document.addEventListener('fullscreenchange', () => {
            if (document.fullscreenElement) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            } else {
                canvas.width = GAME_CONFIG.CANVAS_WIDTH;
                canvas.height = GAME_CONFIG.CANVAS_HEIGHT;
            }
            // Re-center player or adjust game view if necessary
            player.x = canvas.width / 2;
            player.y = canvas.height / 2;
        });


        function initializeUI() {
            // Populate inhibitors
            const inhibitorsGrid = document.getElementById('inhibitorsGrid');
            GAME_CONFIG.INHIBITORS.forEach(inhibitor => {
                const card = document.createElement('div');
                card.className = 'inhibitor-card';
                card.dataset.inhibitorId = inhibitor.id;
                card.style.borderColor = `hsl(${inhibitor.hue}, 80%, 70%)`;
                
                card.innerHTML = `
                    <div class="inhibitor-name" style="color: hsl(${inhibitor.hue}, 80%, 70%)">${inhibitor.name}</div>
                    <div class="inhibitor-desc">${inhibitor.desc}</div>
                `;
                
                card.addEventListener('click', () => toggleInhibitor(inhibitor.id));
                inhibitorsGrid.appendChild(card);
            });
            
            // Difficulty buttons
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                if (btn.dataset.difficulty) {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('[data-difficulty]').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        selectedDifficulty = btn.dataset.difficulty;
                        // Reset inhibitors when changing difficulty
                        selectedInhibitors = [];
                        document.querySelectorAll('.inhibitor-card').forEach(card => {
                            card.classList.remove('selected');
                        });
                        updateInhibitorLimits();
                    });
                }
            });
            
            // Shooting mode buttons
            document.querySelectorAll('[data-shooting]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('[data-shooting]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    shootingMode = btn.dataset.shooting;
                });
            });
            
            
            // Ship customization (main menu)
            updateShipPreview();
            
            document.getElementById('shipShape').addEventListener('change', (e) => {
                shipCustomization.shape = e.target.value;
                updateShipPreview();
                updateShipPreviewCustom();
            });
            
            document.getElementById('shipBodyColor').addEventListener('change', (e) => {
                shipCustomization.bodyColor = e.target.value;
                updateShipPreview();
                updateShipPreviewCustom();
            });
            
            document.getElementById('shipAccentColor').addEventListener('change', (e) => {
                shipCustomization.accentColor = e.target.value;
                updateShipPreview();
                updateShipPreviewCustom();
            });
            
            // Ship customization (customization menu)
            document.getElementById('shipShapeCustom').addEventListener('change', (e) => {
                shipCustomization.shape = e.target.value;
                updateShipPreview();
                updateShipPreviewCustom();
                document.getElementById('shipShape').value = e.target.value;
            });
            
            document.getElementById('shipBodyColorCustom').addEventListener('change', (e) => {
                shipCustomization.bodyColor = e.target.value;
                updateShipPreview();
                updateShipPreviewCustom();
                document.getElementById('shipBodyColor').value = e.target.value;
            });
            
            document.getElementById('shipAccentColorCustom').addEventListener('change', (e) => {
                shipCustomization.accentColor = e.target.value;
                updateShipPreview();
                updateShipPreviewCustom();
                document.getElementById('shipAccentColor').value = e.target.value;
            });
            
            // Tail customization
            document.getElementById('tailWidthSlider').addEventListener('input', (e) => {
                tailCustomization.width = parseInt(e.target.value);
                document.getElementById('tailWidthValue').textContent = tailCustomization.width;
                updateTailPreview();
            });
            
            document.getElementById('tailGlowSlider').addEventListener('input', (e) => {
                tailCustomization.glow = parseInt(e.target.value);
                document.getElementById('tailGlowValue').textContent = tailCustomization.glow;
                updateTailPreview();
            });
            
            document.getElementById('tailColorPicker').addEventListener('change', (e) => {
                tailCustomization.color = e.target.value;
                updateTailPreview();
            });
            
            // Agreement handling
            document.getElementById('disableFlashesCheck').addEventListener('change', (e) => {
                flashingEffectsDisabled = e.target.checked;
                if (flashingEffectsDisabled) {
                    graphicsSettings.screenShake = false;
                    visualSettings.trippyEffects = false;
                    visualSettings.colorPulse = false;
                    showToast('Flashing effects disabled.', 'info');
                } else {
                    graphicsSettings.screenShake = true;
                    visualSettings.trippyEffects = true;
                    visualSettings.colorPulse = true;
                    showToast('Flashing effects enabled.', 'info');
                }
            });

            document.getElementById('agreementCheck').addEventListener('change', (e) => {
                console.log("Agreement checkbox changed. Checked:", e.target.checked);
                const acceptBtn = document.getElementById('acceptAgreementBtn');
                if (e.target.checked) {
                    console.log("Enabling accept button.");
                    acceptBtn.disabled = false;
                    acceptBtn.style.opacity = '1';
                    acceptBtn.style.cursor = 'pointer';
                } else {
                    console.log("Disabling accept button.");
                    acceptBtn.disabled = true;
                    acceptBtn.style.opacity = '0.5';
                    acceptBtn.style.cursor = 'not-allowed';
                }
            });
            
            document.getElementById('acceptAgreementBtn').addEventListener('click', () => {
                console.log("Accept agreement button clicked");
                if (document.getElementById('agreementCheck').checked) {
                    console.log("Agreement checkbox is checked");
                    // Store agreement acceptance
                    localStorage.setItem('voidDrifterAgreement', 'accepted');
                    console.log("Agreement stored in localStorage");
                    showMainMenu();
                    console.log("showMainMenu() called");
                } else {
                    console.log("Agreement checkbox is NOT checked");
                }
            });
            
            // Menu buttons
            // Open pre-start setup instead of starting immediately
            document.getElementById('startGameBtn').addEventListener('click', () => {
                showOverlay('preStartOverlay');
            });
            
            // Pre-start overlay actions
            const preStartStartBtn = document.getElementById('preStartStartBtn');
            if (preStartStartBtn) preStartStartBtn.addEventListener('click', startGame);
            const preStartBackBtn = document.getElementById('preStartBackBtn');
            if (preStartBackBtn) preStartBackBtn.addEventListener('click', () => showOverlay('menuOverlay'));
            document.getElementById('settingsBtn').addEventListener('click', () => showOverlay('settingsOverlay'));
            document.getElementById('inhibitorsBtn').addEventListener('click', () => {
                updateInhibitorLimits();
                showOverlay('inhibitorsOverlay');
            });
            document.getElementById('customizationBtn').addEventListener('click', () => {
                updateAllPreviews();
                showOverlay('customizationOverlay');
            });
            document.getElementById('backFromSettingsBtn').addEventListener('click', () => {
                if (gameState === 'playing') {
                    pauseGame();
                } else if (gameState === 'paused') {
                    showOverlay('pauseOverlay');
                } else {
                    showOverlay('menuOverlay');
                }
            });
            document.getElementById('backFromInhibitorsBtn').addEventListener('click', () => {
                if (gameState === 'playing') {
                    pauseGame();
                } else if (gameState === 'paused') {
                    showOverlay('pauseOverlay');
                } else {
                    showOverlay('preStartOverlay');
                }
            });
            document.getElementById('backFromCustomizationBtn').addEventListener('click', () => {
                if (gameState === 'playing') {
                    pauseGame();
                } else if (gameState === 'paused') {
                    showOverlay('pauseOverlay');
                } else {
                    showOverlay('menuOverlay');
                }
            });
            document.getElementById('clearInhibitorsBtn').addEventListener('click', () => {
                inhibitorStacks.clear();
                selectedInhibitors = [];
                updateInhibitorDisplay();
                showToast('All inhibitors cleared', 'info');
            });
            document.getElementById('playAgainBtn').addEventListener('click', startGame);
            document.getElementById('mainMenuBtn').addEventListener('click', () => showOverlay('menuOverlay'));
            document.getElementById('resumeBtn').addEventListener('click', pauseGame);
            document.getElementById('tutorialBtn').addEventListener('click', () => showOverlay('tutorialOverlay'));
            document.getElementById('closeTutorialBtn').addEventListener('click', () => showOverlay('pauseOverlay'));
            document.getElementById('pauseCustomizationBtn').addEventListener('click', () => {
                updateAllPreviews();
                showOverlay('customizationOverlay');
            });
            document.getElementById('pauseSettingsBtn').addEventListener('click', () => showOverlay('settingsOverlay'));
            document.getElementById('quitBtn').addEventListener('click', () => showOverlay('menuOverlay'));
            
            // Credits button is already in Settings overlay - don't add duplicate
            
            // Add allies configuration
            document.getElementById('alliesBtn').addEventListener('click', () => {
                showOverlay('alliesOverlay');
            });
            document.getElementById('backFromAlliesBtn').addEventListener('click', () => {
                if (gameState === 'playing') {
                    pauseGame();
                } else {
                    showOverlay('preStartOverlay');
                }
            });
            
            // Ally names toggle (moved to Ally Customization)
            const allyNamesToggleCustom = document.getElementById('allyNamesToggleCustom');
            if (allyNamesToggleCustom) {
                showAllyNames = allyNamesToggleCustom.checked;
                allyNamesToggleCustom.addEventListener('change', (e) => {
                    showAllyNames = e.target.checked;
                });
            }
            
            // Ally count buttons
            document.querySelectorAll('[data-ally-count]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('[data-ally-count]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    allyConfig.count = parseInt(btn.dataset.allyCount);
                    console.log('Ally count set to:', allyConfig.count);
                });
            });
            
            // Ally behavior buttons
            document.querySelectorAll('[data-ally-behavior]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('[data-ally-behavior]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    allyConfig.behavior = btn.dataset.allyBehavior;
                    console.log('Ally behavior set to:', allyConfig.behavior);
                });
            });
            
            // Ally customization button
            document.getElementById('allyCustomizationBtn').addEventListener('click', () => {
                updateAllyCustomizationSlots();
                showOverlay('allyCustomizationOverlay');
            });
            
            // Back from ally customization
            document.getElementById('backFromAllyCustomizationBtn').addEventListener('click', () => {
                if (gameState === 'playing') {
                    pauseGame();
                } else {
                    showOverlay('alliesOverlay');
                }
            });
            
            // Leaderboard
            document.getElementById('leaderboardBtn').addEventListener('click', () => {
                loadLeaderboard();
                showOverlay('leaderboardOverlay');
            });
            document.getElementById('backFromLeaderboardBtn').addEventListener('click', () => {
                if (gameState === 'playing') {
                    pauseGame();
                } else {
                    showOverlay('menuOverlay');
                }
            });
            document.getElementById('viewLeaderboardBtn').addEventListener('click', () => {
                loadLeaderboard();
                showOverlay('leaderboardOverlay');
            });
            document.querySelectorAll('.leaderboard-filter-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.leaderboard-filter-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    const difficulty = btn.dataset.difficulty;
                    loadLeaderboard(difficulty, leaderboardSort.by, leaderboardSort.order);
                });
            });
            document.querySelectorAll('.sortable-header').forEach(header => {
                header.addEventListener('click', () => {
                    const sortBy = header.dataset.sort;
                    if (leaderboardSort.by === sortBy) {
                        leaderboardSort.order = leaderboardSort.order === 'asc' ? 'desc' : 'asc';
                    } else {
                        leaderboardSort.by = sortBy;
                        leaderboardSort.order = 'desc'; // Default to descending for new column
                    }
                    const currentDifficulty = document.querySelector('.leaderboard-filter-btn.active').dataset.difficulty;
                    loadLeaderboard(currentDifficulty, leaderboardSort.by, leaderboardSort.order);
                });
            });
            
            // Credits button
            document.getElementById('creditsBtn').addEventListener('click', showCredits);
            
            // Restore defaults button
            document.getElementById('restoreDefaultsBtn').addEventListener('click', restoreHighQualityDefaults);
            const fullscreenBtn = document.getElementById('fullscreenBtn');
            if (fullscreenBtn) {
                fullscreenBtn.addEventListener('click', toggleFullscreen);
            }
            
            // Cursor/crosshair settings
            const cursorEnabledToggle = document.getElementById('cursorEnabledToggle');
            if (cursorEnabledToggle) {
                cursorEnabledToggle.addEventListener('change', (e) => {
                    cursorSettings.enabled = e.target.checked;
                });
            }
            
            const cursorTypeSelect = document.getElementById('cursorTypeSelect');
            if (cursorTypeSelect) {
                cursorTypeSelect.addEventListener('change', (e) => {
                    cursorSettings.type = e.target.value;
                });
            }
            
            const cursorSizeSlider = document.getElementById('cursorSizeSlider');
            if (cursorSizeSlider) {
                cursorSizeSlider.addEventListener('input', (e) => {
                    cursorSettings.size = parseInt(e.target.value);
                    const sizeValue = document.getElementById('cursorSizeValue');
                    if (sizeValue) sizeValue.textContent = cursorSettings.size;
                });
            }
            
            const cursorColorPicker = document.getElementById('cursorColorPicker');
            if (cursorColorPicker) {
                cursorColorPicker.addEventListener('change', (e) => {
                    cursorSettings.color = e.target.value;
                });
            }
            
            const cursorOpacitySlider = document.getElementById('cursorOpacitySlider');
            if (cursorOpacitySlider) {
                cursorOpacitySlider.addEventListener('input', (e) => {
                    cursorSettings.opacity = parseInt(e.target.value) / 100;
                    const opacityValue = document.getElementById('cursorOpacityValue');
                    if (opacityValue) opacityValue.textContent = parseInt(e.target.value);
                });
            }
            
            // Mouse sensitivity
            const mouseSensitivitySlider = document.getElementById('mouseSensitivitySlider');
            if (mouseSensitivitySlider) {
                mouseSensitivitySlider.addEventListener('input', (e) => {
                    mouseSensitivity = parseInt(e.target.value) / 100;
                    const sensitivityValue = document.getElementById('mouseSensitivityValue');
                    if (sensitivityValue) sensitivityValue.textContent = parseInt(e.target.value);
                });
            }
            
            // Secondary weapon hold mode
            const secondaryHoldModeToggle = document.getElementById('secondaryHoldModeToggle');
            if (secondaryHoldModeToggle) {
                secondaryHoldModeToggle.addEventListener('change', (e) => {
                    secondaryHoldMode = e.target.checked;
                });
            }
            
            // HUD toggle functionality
            const hudToggleBtn = document.getElementById('hudToggleBtn');
            if (hudToggleBtn) {
                hudToggleBtn.addEventListener('click', () => {
                    hudVisible = !hudVisible;
                    userToggledHud = true; // User has manually controlled HUD
                    
                    // Reset auto-hide timers when user manually toggles
                    hudAutoHideTimer = 0;
                    hudLevelShowTimer = 0;
                    
                    updateHUDVisibility();
                });
            }

            // Close legend buttons
            document.getElementById('closeLegendLeft').addEventListener('click', closeLegends);
            document.getElementById('closeLegendRight').addEventListener('click', closeLegends);

            // Initially hide the legends
            document.getElementById('gameLegendLeft').style.display = 'none';
            document.getElementById('gameLegendRight').style.display = 'none';
        }
        
        // Restore High Quality Defaults Function
        function restoreHighQualityDefaults() {
            // Set FPS limit to Unlimited
            fpsLimit = 0;
            targetFrameTime = 0;
            document.querySelectorAll('[data-fps-limit]').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.fpsLimit === 'unlimited') {
                    btn.classList.add('active');
                }
            });
            
            // Set Particle Quality to High
            graphicsSettings.particleQuality = 'high';
            document.querySelectorAll('[data-particles]').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.particles === 'high') {
                    btn.classList.add('active');
                }
            });
            
            // Enable Show Grid
            graphicsSettings.showGrid = true;
            document.getElementById('showGridEnabledSettings').checked = true;
            
            // Enable Screen Shake
            graphicsSettings.screenShake = true;
            document.getElementById('screenShakeEnabledSettings').checked = true;
            
            // Enable Visual Effects
            graphicsSettings.visualEffects = true;
            document.getElementById('visualEffectsEnabledSettings').checked = true;
            document.getElementById('particleEffectsEnabledSettings').checked = true;
            
            // Enable all visual effects
            visualSettings.colorPulse = true;
            document.getElementById('colorPulseEnabled').checked = true;
            
            visualSettings.backgroundReact = true;
            document.getElementById('backgroundReactEnabled').checked = true;
            
            visualSettings.trippyEffects = true;
            document.getElementById('trippyEffectsEnabled').checked = true;
            
            visualSettings.backgroundAnimation = true;
            document.getElementById('backgroundAnimationEnabled').checked = true;
            
            // Keep tail warnings enabled (user safety feature)
            visualSettings.tailWarning = true;
            document.getElementById('tailWarningEnabled').checked = true;
            
            // Show success message
            showToast('High quality defaults restored!', 'success', 3000);
            
            console.log('High quality defaults restored:', {
                fpsLimit: fpsLimit === 0 ? 'Unlimited' : fpsLimit,
                particleQuality: graphicsSettings.particleQuality,
                showGrid: graphicsSettings.showGrid,
                screenShake: graphicsSettings.screenShake,
                visualEffects: graphicsSettings.visualEffects,
                colorPulse: visualSettings.colorPulse,
                backgroundReact: visualSettings.backgroundReact,
                trippyEffects: visualSettings.trippyEffects,
                backgroundAnimation: visualSettings.backgroundAnimation
            });
        }
        
        // Add missing functions for ally customization
        function updateAllyCustomizationSlots() {
            const container = document.getElementById('allyCustomizationSlots').querySelector('div');
            container.innerHTML = '';
            
            for (let i = 0; i < allyConfig.count; i++) {
                const slot = document.createElement('div');
                slot.className = 'ally-slot';
                slot.innerHTML = `
                    <h4>Ally ${i + 1}</h4>
                    <label>Shape:
                        <select class="ally-shape-select menu-input" data-ally-index="${i}" style="min-width: 80px; font-size: 11px; padding: 4px;">
                            <option value="triangle" ${allyConfig.shapes[i] === 'triangle' ? 'selected' : ''}>Triangle</option>
                            <option value="diamond" ${allyConfig.shapes[i] === 'diamond' ? 'selected' : ''}>Diamond</option>
                            <option value="arrow" ${allyConfig.shapes[i] === 'arrow' ? 'selected' : ''}>Arrow</option>
                            <option value="star" ${allyConfig.shapes[i] === 'star' ? 'selected' : ''}>Star</option>
                        </select>
                    </label>
                    <label>Body Color:
                        <input type="color" class="ally-body-color color-picker" data-ally-index="${i}" value="${allyConfig.bodyColors[i] || '#00ff88'}" style="width: 40px; height: 25px;">
                    </label>
                    <label>Accent Color:
                        <input type="color" class="ally-accent-color color-picker" data-ally-index="${i}" value="${allyConfig.accentColors[i] || '#00ffff'}" style="width: 40px; height: 25px;">
                    </label>
                    <label>Title Color:
                        <input type="color" class="ally-title-color color-picker" data-ally-index="${i}" value="${allyConfig.titleColors[i] || '#ff4444'}" style="width: 40px; height: 25px;">
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px; justify-content: center; margin: 8px 0;">
                        <input type="checkbox" class="ally-tail-enabled" data-ally-index="${i}" ${allyConfig.tailEnabled[i] ? 'checked' : ''}>
                        Enable Tail
                    </label>
                    <div class="ally-tail-settings" style="display: ${allyConfig.tailEnabled[i] ? 'block' : 'none'}; margin-top: 8px;">
                        <label>Tail Color:
                            <input type="color" class="ally-tail-color color-picker" data-ally-index="${i}" value="${allyConfig.tailColors[i] || '#00ffff'}" style="width: 35px; height: 20px;">
                        </label>
                        <label>Width: <span class="ally-tail-width-value">${allyConfig.tailWidths[i] || 2}</span>
                            <input type="range" class="ally-tail-width volume-slider" data-ally-index="${i}" min="1" max="6" value="${allyConfig.tailWidths[i] || 2}" style="width: 80px;">
                        </label>
                        <label>Glow: <span class="ally-tail-glow-value">${allyConfig.tailGlows[i] || 30}</span>%
                            <input type="range" class="ally-tail-glow volume-slider" data-ally-index="${i}" min="0" max="100" value="${allyConfig.tailGlows[i] || 30}" style="width: 80px;">
                        </label>
                    </div>
                `;
                container.appendChild(slot);
            }
            
            // Add event listeners for new slots
            container.querySelectorAll('.ally-shape-select').forEach(select => {
                select.addEventListener('change', (e) => {
                    const index = parseInt(e.target.dataset.allyIndex);
                    allyConfig.shapes[index] = e.target.value;
                    updateExistingAllies();
                });
            });
            
            container.querySelectorAll('.ally-body-color').forEach(picker => {
                picker.addEventListener('change', (e) => {
                    const index = parseInt(e.target.dataset.allyIndex);
                    allyConfig.bodyColors[index] = e.target.value;
                    updateExistingAllies();
                });
            });
            
            container.querySelectorAll('.ally-accent-color').forEach(picker => {
                picker.addEventListener('change', (e) => {
                    const index = parseInt(e.target.dataset.allyIndex);
                    allyConfig.accentColors[index] = e.target.value;
                    updateExistingAllies();
                });
            });
            
            // Ally title color settings
            container.querySelectorAll('.ally-title-color').forEach(picker => {
                picker.addEventListener('change', (e) => {
                    const index = parseInt(e.target.dataset.allyIndex);
                    allyConfig.titleColors[index] = e.target.value;
                    updateExistingAllies();
                });
            });
            
            // Ally tail settings
            container.querySelectorAll('.ally-tail-enabled').forEach(checkbox => {
                checkbox.addEventListener('change', (e) => {
                    const index = parseInt(e.target.dataset.allyIndex);
                    allyConfig.tailEnabled[index] = e.target.checked;
                    
                    // Show/hide tail settings
                    const tailSettings = e.target.closest('.ally-slot').querySelector('.ally-tail-settings');
                    tailSettings.style.display = e.target.checked ? 'block' : 'none';
                    
                    updateExistingAllies();
                });
            });
            
            container.querySelectorAll('.ally-tail-color').forEach(picker => {
                picker.addEventListener('change', (e) => {
                    const index = parseInt(e.target.dataset.allyIndex);
                    allyConfig.tailColors[index] = e.target.value;
                    updateExistingAllies();
                });
            });
            
            container.querySelectorAll('.ally-tail-width').forEach(slider => {
                slider.addEventListener('input', (e) => {
                    const index = parseInt(e.target.dataset.allyIndex);
                    allyConfig.tailWidths[index] = parseInt(e.target.value);
                    const valueDisplay = e.target.closest('.ally-slot').querySelector('.ally-tail-width-value');
                    valueDisplay.textContent = e.target.value;
                    updateExistingAllies();
                });
            });
            
            container.querySelectorAll('.ally-tail-glow').forEach(slider => {
                slider.addEventListener('input', (e) => {
                    const index = parseInt(e.target.dataset.allyIndex);
                    allyConfig.tailGlows[index] = parseInt(e.target.value);
                    const valueDisplay = e.target.closest('.ally-slot').querySelector('.ally-tail-glow-value');
                    valueDisplay.textContent = e.target.value;
                    updateExistingAllies();
                });
            });
        }
        
        // Function to update existing allies when customization changes
        function updateExistingAllies() {
            friendlyBots.forEach(bot => {
                if (bot.type === 'ally' && bot.allyIndex !== undefined) {
                    const index = bot.allyIndex;
                    
                    // Update appearance
                    bot.shape = allyConfig.shapes[index % allyConfig.shapes.length] || 'triangle';
                    bot.bodyColor = allyConfig.bodyColors[index % allyConfig.bodyColors.length] || '#00ff88';
                    bot.accentColor = allyConfig.accentColors[index % allyConfig.accentColors.length] || '#00ffff';
                    bot.radius = allyConfig.sizes[index % allyConfig.sizes.length] || 14;
                    bot.titleColor = allyConfig.titleColors[index % allyConfig.titleColors.length] || '#ff4444';
                    
                    // Update tail settings
                    bot.tailEnabled = allyConfig.tailEnabled[index % allyConfig.tailEnabled.length] || false;
                    bot.tailColor = allyConfig.tailColors[index % allyConfig.tailColors.length] || '#00ffff';
                    bot.tailWidth = allyConfig.tailWidths[index % allyConfig.tailWidths.length] || 2;
                    bot.tailGlow = allyConfig.tailGlows[index % allyConfig.tailGlows.length] || 30;
                    
                    // Initialize tail segments if tail is enabled and not already initialized
                    if (bot.tailEnabled && !bot.tailSegments) {
                        bot.tailSegments = [];
                    }
                }
            });
        }
        
        // Add missing in-game inhibitor menu functions
        function showIngameInhibitorMenu() {
            const menu = document.getElementById('ingameInhibitorMenu');
            const list = document.getElementById('ingameInhibitorList');
            
            // Clear and populate
            list.innerHTML = '';
            
            GAME_CONFIG.INHIBITORS.forEach(inhibitor => {
                const item = document.createElement('div');
                item.className = 'ingame-inhibitor-item';
                item.dataset.inhibitorId = inhibitor.id;
                
                const currentStack = inhibitorStacks.get(inhibitor.id) || 0;
                const stackText = currentStack > 1 ? ` x${currentStack}` : '';
                
                item.innerHTML = `
                    <div style="font-weight: bold; color: hsl(${inhibitor.hue}, 80%, 70%);">
                        ${inhibitor.name}${stackText}
                    </div>
                    <div style="font-size: 0.7rem; opacity: 0.8;">${inhibitor.desc}</div>
                `;
                
                if (currentStack > 0) {
                    item.classList.add('selected');
                }
                
                item.addEventListener('click', () => {
                    toggleInhibitor(inhibitor.id);
                    // Refresh the menu
                    showIngameInhibitorMenu();
                });
                
                list.appendChild(item);
            });
            
            menu.style.display = 'block';
        }
        
        function hideIngameInhibitorMenu() {
            document.getElementById('ingameInhibitorMenu').style.display = 'none';
        }
        
        // Continue initializeUI function - this code was orphaned
        function initializeUIExtensions() {
            // Ally shape toggles
            const shapeMap = {
                'allyShapeTriangle': 'triangle',
                'allyShapeDiamond': 'diamond',
                'allyShapeArrow': 'arrow',
                'allyShapeStar': 'star'
            };
            
            Object.keys(shapeMap).forEach(checkboxId => {
                const element = document.getElementById(checkboxId);
                if (element) {
                    element.addEventListener('change', () => {
                        allyConfig.shapes = [];
                        Object.keys(shapeMap).forEach(id => {
                            const checkbox = document.getElementById(id);
                            if (checkbox && checkbox.checked) {
                                allyConfig.shapes.push(shapeMap[id]);
                            }
                        });
                        
                        // Ensure at least one shape is selected
                        if (allyConfig.shapes.length === 0) {
                            allyConfig.shapes = ['triangle'];
                            const triangleElement = document.getElementById('allyShapeTriangle');
                            if (triangleElement) triangleElement.checked = true;
                        }
                    });
                }
            });
            
            // HUD auto-hide toggle
            const hudAutoHideToggle = document.getElementById('hudAutoHideToggle');
            if (hudAutoHideToggle) {
                hudAutoHide = hudAutoHideToggle.checked;
                hudAutoHideToggle.addEventListener('change', (e) => {
                    hudAutoHide = e.target.checked;
                });
            }

            // Ammo customization buttons
            document.querySelectorAll('[data-ammo-type]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('[data-ammo-type]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    ammoCustomization.type = btn.dataset.ammoType;
                    updateAmmoPreview();
                });
            });
            
            document.querySelectorAll('[data-ammo-size]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('[data-ammo-size]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    ammoCustomization.size = btn.dataset.ammoSize;
                    updateAmmoPreview();
                });
            });
            
            document.querySelectorAll('[data-ammo-color]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('[data-ammo-color]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    ammoCustomization.color = btn.dataset.ammoColor;
                    updateAmmoPreview();
                });
            });
            
            const showGridSettings = document.getElementById('showGridEnabledSettings');
            if (showGridSettings) {
                showGridSettings.addEventListener('change', (e) => {
                    graphicsSettings.showGrid = e.target.checked;
                });
            }
            
            const screenShakeSettings = document.getElementById('screenShakeEnabledSettings');
            if (screenShakeSettings) {
                screenShakeSettings.addEventListener('change', (e) => {
                    graphicsSettings.screenShake = e.target.checked;
                });
            }
            
            const visualEffectsSettings = document.getElementById('visualEffectsEnabledSettings');
            if (visualEffectsSettings) {
                visualEffectsSettings.addEventListener('change', (e) => {
                    graphicsSettings.visualEffects = e.target.checked;
                });
            }
            
            const particleEffectsSettings = document.getElementById('particleEffectsEnabledSettings');
            if (particleEffectsSettings) {
                particleEffectsSettings.addEventListener('change', (e) => {
                    graphicsSettings.visualEffects = e.target.checked;
                });
            }
            
            // Graphics settings in settings menu
            document.querySelectorAll('[data-particles]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('[data-particles]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    graphicsSettings.particleQuality = btn.dataset.particles;
                });
            });
            
            // Settings sliders
            const musicVolumeSlider = document.getElementById('musicVolumeSlider');
            if (musicVolumeSlider) {
                musicVolumeSlider.addEventListener('input', (e) => {
                    musicVolume = parseInt(e.target.value);
                    const valueDisplay = document.getElementById('musicVolumeValue');
                    if (valueDisplay) valueDisplay.textContent = musicVolume;
                    if (youtubePlayer && youtubeReady) {
                        youtubePlayer.setVolume(musicVolume);
                    }
                    // Sync with music controls volume slider
                    const volumeControl = document.getElementById('volumeControl');
                    if (volumeControl) volumeControl.value = musicVolume;
                });
            }
            
            const sfxVolumeSlider = document.getElementById('sfxVolumeSlider');
            if (sfxVolumeSlider) {
                sfxVolumeSlider.addEventListener('input', (e) => {
                    sfxVolume = parseInt(e.target.value);
                    const valueDisplay = document.getElementById('sfxVolumeValue');
                    if (valueDisplay) valueDisplay.textContent = sfxVolume;
                });
            }
            
            const reactivitySlider = document.getElementById('reactivitySlider');
            if (reactivitySlider) {
                reactivitySlider.addEventListener('input', (e) => {
                    musicReactivity = parseInt(e.target.value);
                    const valueDisplay = document.getElementById('reactivityValue');
                    if (valueDisplay) valueDisplay.textContent = musicReactivity;
                });
            }
            
            // FPS limit buttons
            document.querySelectorAll('[data-fps-limit]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('[data-fps-limit]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    const limit = btn.dataset.fpsLimit;
                    fpsLimit = limit === 'unlimited' ? 0 : parseInt(limit);
                    targetFrameTime = fpsLimit > 0 ? 1000 / fpsLimit : 0;
                });
            });
            
            // Visual effects toggles
            const colorPulseToggle = document.getElementById('colorPulseEnabled');
            if (colorPulseToggle) {
                colorPulseToggle.addEventListener('change', (e) => {
                    visualSettings.colorPulse = e.target.checked;
                });
            }
            
            const backgroundReactToggle = document.getElementById('backgroundReactEnabled');
            if (backgroundReactToggle) {
                backgroundReactToggle.addEventListener('change', (e) => {
                    visualSettings.backgroundReact = e.target.checked;
                });
            }
            
            const trippyEffectsToggle = document.getElementById('trippyEffectsEnabled');
            if (trippyEffectsToggle) {
                trippyEffectsToggle.addEventListener('change', (e) => {
                    visualSettings.trippyEffects = e.target.checked;
                });
            }
            
            const tailWarningToggle = document.getElementById('tailWarningEnabled');
            if (tailWarningToggle) {
                tailWarningToggle.addEventListener('change', (e) => {
                    visualSettings.tailWarning = e.target.checked;
                });
            }
            
            const backgroundAnimationToggle = document.getElementById('backgroundAnimationEnabled');
            if (backgroundAnimationToggle) {
                backgroundAnimationToggle.addEventListener('change', (e) => {
                    visualSettings.backgroundAnimation = e.target.checked;
                });
            }
            
            const backgroundMovementToggle = document.getElementById('backgroundMovementEnabled');
            if (backgroundMovementToggle) {
                backgroundMovementToggle.addEventListener('change', (e) => {
                    visualSettings.backgroundMovement = e.target.checked;
                });
            }
            
            // Music controls - YouTube only
            const playPauseBtn = document.getElementById('playPauseBtn');
            if (playPauseBtn) {
                playPauseBtn.addEventListener('click', () => {
                    console.log('üéµ Play/Pause clicked');
                    if (youtubePlayer && youtubeReady) {
                        try {
                            const playerState = youtubePlayer.getPlayerState();
                            console.log('Current state:', playerState);
                            
                            if (playerState === YT.PlayerState.PLAYING) {
                                youtubePlayer.pauseVideo();
                                console.log('‚è∏Ô∏è Music paused');
                            } else {
                                youtubePlayer.playVideo();
                                console.log('‚ñ∂Ô∏è Music playing');
                            }
                        } catch (e) {
                            console.error('YouTube control error:', e);
                            showToast('Music control failed', 'warning');
                        }
                    } else {
                        console.warn('üö® YouTube player not ready');
                        showToast('YouTube music not ready', 'warning');
                        // Try to reinitialize
                        if (window.YT && window.YT.Player) {
                            initYouTubePlayer();
                        } else {
                            loadYouTubeAPI();
                        }
                    }
                });
            }
            
            const prevBtn = document.getElementById('prevBtn');
            if (prevBtn) {
                prevBtn.addEventListener('click', () => {
                    console.log('‚èÆÔ∏è Previous clicked');
                    if (youtubePlayer && youtubeReady) {
                        try {
                            youtubePlayer.previousVideo();
                            console.log('‚èÆÔ∏è Previous track');
                        } catch (e) {
                            console.warn('Previous control error:', e);
                        }
                    } else {
                        showToast('YouTube music not ready', 'warning');
                    }
                });
            }
            
            const nextBtn = document.getElementById('nextBtn');
            if (nextBtn) {
                nextBtn.addEventListener('click', () => {
                    console.log('‚è≠Ô∏è Next clicked');
                    if (youtubePlayer && youtubeReady) {
                        try {
                            youtubePlayer.nextVideo();
                            console.log('‚è≠Ô∏è Next track');
                        } catch (e) {
                            console.warn('Next control error:', e);
                        }
                    } else {
                        showToast('YouTube music not ready', 'warning');
                    }
                });
            }
            
            const shuffleBtn = document.getElementById('shuffleBtn');
            if (shuffleBtn) {
                shuffleBtn.addEventListener('click', () => {
                    console.log('üîÄ Shuffle clicked');
                    if (youtubePlayer && youtubeReady) {
                        try {
                            youtubePlayer.setShuffle(true);
                            youtubePlayer.nextVideo();
                            setTimeout(() => youtubePlayer.setShuffle(false), 100);
                            console.log('üîÄ Playlist shuffled');
                        } catch (e) {
                            console.warn('Shuffle control error:', e);
                        }
                    } else {
                        showToast('YouTube music not ready', 'warning');
                    }
                });
            }
            
            // Volume control synchronization
            const volumeControl = document.getElementById('volumeControl');
            if (volumeControl) {
                volumeControl.addEventListener('input', (e) => {
                    const volume = parseInt(e.target.value);
                    musicVolume = volume;
                    
                    // Sync with settings menu slider
                    const settingsSlider = document.getElementById('musicVolumeSlider');
                    const settingsValue = document.getElementById('musicVolumeValue');
                    if (settingsSlider) settingsSlider.value = volume;
                    if (settingsValue) settingsValue.textContent = volume;
                    
                    if (youtubePlayer && youtubeReady) {
                        try {
                            youtubePlayer.setVolume(volume);
                        } catch (e) {
                            console.warn('Volume control error:', e);
                        }
                    }
                });
            }
            
            // Add ally multiplier sliders event handlers
            const allyHpSlider = document.getElementById('allyHpMultiplier');
            if (allyHpSlider) {
                allyHpSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    allyMultipliers.hp = value / 100;
                    const valueDisplay = document.getElementById('allyHpMultiplierValue');
                    if (valueDisplay) valueDisplay.textContent = value;
                });
            }
            
            const allyDamageSlider = document.getElementById('allyDamageMultiplier');
            if (allyDamageSlider) {
                allyDamageSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    allyMultipliers.damage = value / 100;
                    const valueDisplay = document.getElementById('allyDamageMultiplierValue');
                    if (valueDisplay) valueDisplay.textContent = value;
                });
            }
            
            const allySpeedSlider = document.getElementById('allySpeedMultiplier');
            if (allySpeedSlider) {
                allySpeedSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    allyMultipliers.speed = value / 100;
                    const valueDisplay = document.getElementById('allySpeedMultiplierValue');
                    if (valueDisplay) valueDisplay.textContent = value;
                });
            }
        }

        function toggleInhibitor(inhibitorId) {
            const inhibitor = GAME_CONFIG.INHIBITORS.find(inh => inh.id === inhibitorId);
            const currentStack = inhibitorStacks.get(inhibitorId) || 0;
            const maxStack = inhibitor.stackable ? 5 : 1;
            const difficulty = GAME_CONFIG.DIFFICULTIES[selectedDifficulty];
            const maxInhibitors = difficulty.inhibitorLimit;
            
            // Get total unique inhibitors currently selected
            const currentUniqueInhibitors = [...inhibitorStacks.keys()].length;
            
            if (currentStack >= maxStack) {
                // Remove all stacks of this inhibitor
                inhibitorStacks.delete(inhibitorId);
                selectedInhibitors = selectedInhibitors.filter(id => id !== inhibitorId);
                showToast(`${inhibitor.name} removed`, 'info');
            } else {
                // Check if we need to enforce limits
                if (currentStack === 0 && currentUniqueInhibitors >= maxInhibitors && maxInhibitors !== Infinity) {
                    showToast(`Maximum ${maxInhibitors} inhibitors allowed on ${selectedDifficulty} difficulty`, 'warning');
                    return;
                }
                
                // Add one stack
                inhibitorStacks.set(inhibitorId, currentStack + 1);
                if (!selectedInhibitors.includes(inhibitorId)) {
                    selectedInhibitors.push(inhibitorId);
                }
                
                const stackText = inhibitor.stackable ? ` (${currentStack + 1}/${maxStack})` : '';
                showToast(`${inhibitor.name} selected${stackText}`, 'success');
            }
            
            updateInhibitorDisplay();
            updateInhibitorLimits();
        }
        
        function updateInhibitorDisplay() {
            document.querySelectorAll('.inhibitor-card').forEach(card => {
                const inhibitorId = card.dataset.inhibitorId;
                const currentStack = inhibitorStacks.get(inhibitorId) || 0;
                const inhibitor = GAME_CONFIG.INHIBITORS.find(inh => inh.id === inhibitorId);
                const maxStack = inhibitor.stackable ? 5 : 1;
                
                card.classList.toggle('selected', currentStack > 0);
                
                // Update display to show stack count
                const nameEl = card.querySelector('.inhibitor-name');
                if (nameEl) {
                    const baseName = inhibitor.name;
                    const stackText = currentStack > 1 ? ` x${currentStack}` : '';
                    const maxText = inhibitor.stackable && currentStack > 0 ? ` (${currentStack}/${maxStack})` : '';
                    nameEl.textContent = baseName + stackText + maxText;
                }
            });
            
            // Update in-game menu if it's open (moved to later in code)
        }

        function updateInhibitorLimits() {
            const difficulty = GAME_CONFIG.DIFFICULTIES[selectedDifficulty];
            const maxInhibitors = difficulty.inhibitorLimit;
            const currentUniqueInhibitors = [...inhibitorStacks.keys()].length;
            
            // Update both displays
            const maxText = maxInhibitors === Infinity ? '‚àû' : maxInhibitors;
            const maxEl = document.getElementById('maxInhibitors');
            if (maxEl) maxEl.textContent = maxText;
            const maxDisplayEl = document.getElementById('maxInhibitorsDisplay');
            if (maxDisplayEl) maxDisplayEl.textContent = maxText;
            
            // Clear inhibitors if changing difficulty would exceed limit
            if (maxInhibitors !== Infinity && currentUniqueInhibitors > maxInhibitors) {
                inhibitorStacks.clear();
                selectedInhibitors = [];
                showToast(`Inhibitors cleared due to difficulty limit (${maxInhibitors})`, 'warning');
            }
            
            document.querySelectorAll('.inhibitor-card').forEach(card => {
                const inhibitorId = card.dataset.inhibitorId;
                const isSelected = inhibitorStacks.has(inhibitorId);
                const canSelect = isSelected || currentUniqueInhibitors < maxInhibitors || maxInhibitors === Infinity;
                
                card.classList.toggle('selected', isSelected);
                card.classList.toggle('disabled', !canSelect);
            });
            
            updateInhibitorDisplay();
        }
        
        function updateAmmoPreview() {
            const preview = document.getElementById('ammoPreview');
            const canvas = document.createElement('canvas');
            canvas.width = 100;
            canvas.height = 60;
            const ctx = canvas.getContext('2d');
            
            ctx.save();
            ctx.translate(50, 30);
            
            const stats = getAmmoStats();
            ctx.fillStyle = ammoCustomization.color;
            ctx.strokeStyle = ammoCustomization.color;
            ctx.lineWidth = 1;
            ctx.shadowColor = ammoCustomization.color;
            ctx.shadowBlur = 10;
            
            // Draw bullet preview
            ctx.beginPath();
            const size = stats.size * 1.5; // Make it bigger for preview
            
            if (ammoCustomization.type === 'piercing') {
                // Diamond
                ctx.moveTo(0, -size);
                ctx.lineTo(size * 0.7, 0);
                ctx.lineTo(0, size);
                ctx.lineTo(-size * 0.7, 0);
                ctx.closePath();
            } else if (ammoCustomization.type === 'explosive') {
                // Hexagon
                for (let i = 0; i < 6; i++) {
                    const angle = (i * Math.PI) / 3;
                    const x = Math.cos(angle) * size;
                    const y = Math.sin(angle) * size;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
            } else if (ammoCustomization.type === 'spread') {
                // Triangle
                ctx.moveTo(0, -size);
                ctx.lineTo(size * 0.8, size * 0.6);
                ctx.lineTo(-size * 0.8, size * 0.6);
                ctx.closePath();
            } else {
                // Circle
                ctx.arc(0, 0, size, 0, Math.PI * 2);
            }
            
            ctx.fill();
            ctx.restore();
            
            // Add stats text
            ctx.fillStyle = '#ffffff';
            ctx.font = '10px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(`Speed: ${Math.round(stats.speed)}`, 50, 50);
            ctx.fillText(`Damage: ${stats.damage.toFixed(1)}x`, 50, 58);
            
            preview.innerHTML = '';
            preview.appendChild(canvas);
        }
        
        function updateShipPreview() {
            const preview = document.getElementById('shipPreview');
            const canvas = document.createElement('canvas');
            canvas.width = 60;
            canvas.height = 60;
            const ctx = canvas.getContext('2d');
            
            drawShipPreview(ctx, 30, 30, 12);
            
            preview.innerHTML = '';
            preview.appendChild(canvas);
        }
        
        function updateShipPreviewCustom() {
            const preview = document.getElementById('shipPreviewCustom');
            const canvas = document.createElement('canvas');
            canvas.width = 60;
            canvas.height = 60;
            const ctx = canvas.getContext('2d');
            
            drawShipPreview(ctx, 30, 30, 12);
            
            preview.innerHTML = '';
            preview.appendChild(canvas);
        }
        
        function drawShipPreview(ctx, centerX, centerY, radius) {
            ctx.save();
            ctx.translate(centerX, centerY);
            
            ctx.fillStyle = shipCustomization.bodyColor;
            ctx.strokeStyle = shipCustomization.accentColor;
            ctx.lineWidth = 2;
            ctx.shadowColor = shipCustomization.accentColor;
            ctx.shadowBlur = 10;
            
            ctx.beginPath();
            
            switch (shipCustomization.shape) {
                case 'triangle':
                    ctx.moveTo(radius, 0);
                    ctx.lineTo(-radius * 0.7, radius * 0.6);
                    ctx.lineTo(-radius * 0.4, 0);
                    ctx.lineTo(-radius * 0.7, -radius * 0.6);
                    ctx.closePath();
                    break;
                case 'diamond':
                    ctx.moveTo(radius, 0);
                    ctx.lineTo(0, radius * 0.7);
                    ctx.lineTo(-radius * 0.8, 0);
                    ctx.lineTo(0, -radius * 0.7);
                    ctx.closePath();
                    break;
                case 'arrow':
                    ctx.moveTo(radius, 0);
                    ctx.lineTo(-radius * 0.5, radius * 0.4);
                    ctx.lineTo(-radius * 0.3, radius * 0.2);
                    ctx.lineTo(-radius * 0.8, radius * 0.3);
                    ctx.lineTo(-radius * 0.8, -radius * 0.3);
                    ctx.lineTo(-radius * 0.3, -radius * 0.2);
                    ctx.lineTo(-radius * 0.5, -radius * 0.4);
                    ctx.closePath();
                    break;
                case 'star':
                    const spikes = 5;
                    const outerRadius = radius;
                    const innerRadius = radius * 0.5;
                    for (let i = 0; i < spikes * 2; i++) {
                        const r = i % 2 === 0 ? outerRadius : innerRadius;
                        const angle = (i * Math.PI) / spikes;
                        const x = Math.cos(angle) * r;
                        const y = Math.sin(angle) * r;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    break;
                case 'circle':
                default:
                    ctx.arc(0, 0, radius, 0, Math.PI * 2);
                    break;
            }
            
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }
        
        function updateTailPreview() {
            const preview = document.getElementById('tailPreview');
            const canvas = document.createElement('canvas');
            canvas.width = 150;
            canvas.height = 80;
            const ctx = canvas.getContext('2d');
            
            ctx.save();
            
            // Draw a sample tail
            const tailPoints = [];
            for (let i = 0; i < 20; i++) {
                const x = 20 + i * 5;
                const y = 40 + Math.sin(i * 0.3) * 10;
                tailPoints.push({x, y});
            }
            
            ctx.globalCompositeOperation = 'lighter';
            ctx.strokeStyle = tailCustomization.color + 'EE';
            ctx.lineWidth = tailCustomization.width;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            const glowIntensity = tailCustomization.glow / 100;
            ctx.shadowColor = tailCustomization.color;
            ctx.shadowBlur = 30 * glowIntensity;
            
            // Draw multiple passes for glow effect
            for (let pass = 0; pass < 2; pass++) {
                ctx.beginPath();
                tailPoints.forEach((point, i) => {
                    if (i === 0) ctx.moveTo(point.x, point.y);
                    else ctx.lineTo(point.x, point.y);
                });
                ctx.stroke();
                
                if (pass === 0) {
                    ctx.strokeStyle = tailCustomization.color + '99';
                    ctx.lineWidth = tailCustomization.width * 1.8;
                    ctx.shadowBlur = 50 * glowIntensity;
                }
            }
            
            ctx.restore();
            
            // Add ship at end
            drawShipPreview(ctx, tailPoints[tailPoints.length - 1].x, tailPoints[tailPoints.length - 1].y, 8);
            
            preview.innerHTML = '';
            preview.appendChild(canvas);
        }
        
        function updateAllPreviews() {
            updateShipPreview();
            updateShipPreviewCustom();
            updateTailPreview();
            updateAmmoPreview();
            
            // Sync form values
            document.getElementById('shipShapeCustom').value = shipCustomization.shape;
            document.getElementById('shipBodyColorCustom').value = shipCustomization.bodyColor;
            document.getElementById('shipAccentColorCustom').value = shipCustomization.accentColor;
            document.getElementById('tailWidthSlider').value = tailCustomization.width;
            document.getElementById('tailGlowSlider').value = tailCustomization.glow;
            document.getElementById('tailColorPicker').value = tailCustomization.color;
            document.getElementById('tailWidthValue').textContent = tailCustomization.width;
            document.getElementById('tailGlowValue').textContent = tailCustomization.glow;
        }

        // Input Handling
        function setupInput() {
            // Keyboard
            document.addEventListener('keydown', (e) => {
                keys.add(e.key.toLowerCase());
                
                if (e.key.toLowerCase() === 'escape' || e.key.toLowerCase() === 'p') {
                    e.preventDefault();
                    pauseGame();
                }
                
                // Music controls
                if (e.key.toLowerCase() === 'm') {
                    e.preventDefault();
                    document.getElementById('playPauseBtn').click();
                }
                if (e.key === ',') {
                    e.preventDefault();
                    document.getElementById('prevBtn').click();
                }
                if (e.key === '.') {
                    e.preventDefault();
                    document.getElementById('nextBtn').click();
                }
                if (e.key.toLowerCase() === 'tab') {
                    e.preventDefault();
                    document.getElementById('nextBtn').click();
                }
                
                // In-game inhibitor menu toggle
                if (e.key.toLowerCase() === 'i' && gameState === 'playing') {
                    e.preventDefault();
                    const menu = document.getElementById('ingameInhibitorMenu');
                    if (menu.style.display === 'none' || !menu.style.display) {
                        showIngameInhibitorMenu();
                    } else {
                        hideIngameInhibitorMenu();
                    }
                }
            });

            document.addEventListener('keyup', (e) => {
                keys.delete(e.key.toLowerCase());
            });

            // Mouse
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                mouse.x = (e.clientX - rect.left) * (GAME_CONFIG.CANVAS_WIDTH / rect.width);
                mouse.y = (e.clientY - rect.top) * (GAME_CONFIG.CANVAS_HEIGHT / rect.height);
            });

            canvas.addEventListener('mousedown', (e) => {
                e.preventDefault();
                if (e.button === 0) {
                    mouse.down = true;
                    // Handle click shooting
                    if (shootingMode === 'click' && gameState === 'playing' && player && clickShootCooldown <= 0) {
                        const mods = calculateModifiers();
                        firePrimary(mods);
                        clickShootCooldown = 1 / (player.fireRate * mods.fireRate);
                    }
                }
                if (e.button === 2) mouse.rightDown = true;
            });

            canvas.addEventListener('mouseup', (e) => {
                if (e.button === 0) mouse.down = false;
                if (e.button === 2) {
                    mouse.rightDown = false;
                    // Fire secondary weapon when releasing right click
                    if (secondaryCharging && gameState === 'playing' && player) {
                        const chargeLevel = secondaryChargeTime / maxSecondaryCharge;
                        
                        // Reduced nerf for hold mode - still powerful
                        const damageMultiplier = secondaryHoldMode ? 0.95 : 1.0;
                        fireSecondary(chargeLevel, damageMultiplier);
                        
                        secondaryCharging = false;
                        secondaryChargeTime = 0;
                    }
                }
            });
            
            // Disable right-click context menu on canvas
            canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                return false;
            });
            
            // Mouse wheel for ammo switching
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                if (gameState === 'playing') {
                    // Change ammo type with mouse wheel
                    if (e.deltaY > 0) {
                        // Scroll down - next ammo type
                        currentAmmoTypeIndex = (currentAmmoTypeIndex + 1) % ammoTypes.length;
                    } else {
                        // Scroll up - previous ammo type
                        currentAmmoTypeIndex = (currentAmmoTypeIndex - 1 + ammoTypes.length) % ammoTypes.length;
                    }
                    
                    ammoCustomization.type = ammoTypes[currentAmmoTypeIndex];
                    updateAmmoButtonHighlight();
                    showToast(`Ammo: ${ammoCustomization.type.toUpperCase()}`, 'info', 1500);
                }
            });
        }

        function updateAmmoButtonHighlight() {
            // Update ammo type buttons in customization menu
            document.querySelectorAll('[data-ammo-type]').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.ammoType === ammoCustomization.type);
            });
        }

        // Simple collision detection without spatial grid
        
        
        // Initialize Game with optimizations
        function init() {
            initAudio();
            loadYouTubeAPI();
            initializeUI();
            initializeUIExtensions(); // Initialize the orphaned UI code
            setupInput();
            updateInhibitorLimits();
            loadLearningState(); // Load player learning state on init
            
            // This is now handled by checkUserAndShowAgreement
            // which is called at the end of the second script tag.
            
            // Start game loop
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
            
            console.log('Enhanced VoidDrifter initialized with all functions working!');
        }

        // Additional YouTube API Helper Functions
        
        
        
        
        
        
        
        
        
        
        // Music controls draggable functionality
        function makeMusicControlsDraggable() {
            const musicControls = document.getElementById('musicControls');
            const header = musicControls.querySelector('.music-controls-header');
            const closeBtn = document.getElementById('closeMusicBtn');
            
            let isDragging = false;
            let dragOffset = { x: 0, y: 0 };
            
            const dragTriggers = [header, musicControls]; // Allow dragging by header or body
            
            dragTriggers.forEach(trigger => {
                trigger.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('music-controls-close') || 
                        e.target.classList.contains('music-btn') ||
                        e.target.classList.contains('volume-slider')) {
                        return;
                    }
                    
                    isDragging = true;
                    musicControlsMoved = true; // User has taken control
                    const rect = musicControls.getBoundingClientRect();
                    dragOffset.x = e.clientX - rect.left;
                    dragOffset.y = e.clientY - rect.top;
                    
                    musicControls.style.transition = 'none';
                    document.body.style.userSelect = 'none';
                    e.preventDefault();
                });
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const newX = e.clientX - dragOffset.x;
                const newY = e.clientY - dragOffset.y;
                
                const maxX = window.innerWidth - musicControls.offsetWidth;
                const maxY = window.innerHeight - musicControls.offsetHeight;
                
                const constrainedX = Math.max(0, Math.min(newX, maxX));
                const constrainedY = Math.max(0, Math.min(newY, maxY));
                
                musicControls.style.left = constrainedX + 'px';
                musicControls.style.top = constrainedY + 'px';
                musicControls.style.bottom = 'auto';
                musicControls.style.right = 'auto';
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
                document.body.style.userSelect = '';
                musicControls.style.transition = '';
            });
            
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    musicControls.style.display = 'none';
                    musicPlayerHidden = true;
                });
            }

            if ('ResizeObserver' in window) {
                const ro = new ResizeObserver(entries => {
                    for (const entry of entries) {
                        const width = entry.contentRect.width;
                        musicControls.classList.toggle('expanded', width > 300);

                        // Auto-scale font
                        const baseWidth = 360; // The original width
                        const baseFontSize = 12; // The original font size
                        const newFontSize = Math.max(8, (width / baseWidth) * baseFontSize);
                        musicControls.style.fontSize = `${newFontSize}px`;
                    }
                });
                ro.observe(musicControls);
            }
        }

        // Start the game when page loads
        document.addEventListener('DOMContentLoaded', () => {
            init();
            makeMusicControlsDraggable();
            repositionMusicControls();
            window.addEventListener('beforeunload', saveLearningState); // Save learning state before unload

            // --- Auth Logic ---
            const loginBtn = document.getElementById('loginBtn');
            const signupBtn = document.getElementById('signupBtn');
            const logoutBtn = document.getElementById('logoutBtn');

            loginBtn.addEventListener('click', () => {
                window.location.href = 'login.html';
            });

            signupBtn.addEventListener('click', () => {
                window.location.href = 'signup.html';
            });

            logoutBtn.addEventListener('click', async () => {
                const { error } = await supabaseClient.auth.signOut();
                if (error) {
                    alert(error.message);
                } else {
                    localStorage.removeItem('voidDrifterAgreement');
                    await updateUIForUser(null);
                    showOverlay('agreementOverlay');
                }
            });

            async function checkUserAndShowAgreement() {
                const agreementAccepted = localStorage.getItem('voidDrifterAgreement');
                
                const { data: { session }, error: sessionError } = await supabaseClient.auth.getSession();

                if (sessionError) {
                    console.error("Error getting session:", sessionError);
                    showOverlay('agreementOverlay'); // Show agreement as a fallback
                    return;
                }

                await updateUIForUser(session?.user);

                if (agreementAccepted === 'accepted' || session?.user) {
                    if(session?.user && agreementAccepted !== 'accepted'){
                        localStorage.setItem('voidDrifterAgreement', 'accepted');
                    }
                    showMainMenu();
                } else {
                    showOverlay('agreementOverlay');
                }
            }

            async function updateUIForUser(user) {
                const userInfo = document.getElementById('user-info');
                const usernameEl = document.getElementById('username');
                const avatarEl = document.getElementById('avatar');

                try {
                    if (user) {
                        loginBtn.style.display = 'none';
                        signupBtn.style.display = 'none';
                        logoutBtn.style.display = 'block';
                        userInfo.style.display = 'flex';

                        // Fetch profile
                        const { data: profile, error } = await supabaseClient
                            .from('profiles')
                            .select('username, avatar_url')
                            .eq('id', user.id)
                            .single();

                        if (error) {
                            console.error("Error fetching profile:", error);
                        }

                        if (profile) {
                            usernameEl.textContent = profile.username || 'Player';
                            document.getElementById('playerNameInput').value = profile.username || 'Player';
                            if (profile.avatar_url) {
                                avatarEl.style.backgroundImage = `url(${profile.avatar_url})`;
                            }
                        } else {
                            usernameEl.textContent = 'Player';
                            document.getElementById('playerNameInput').value = 'Player';
                        }

                    } else {
                        loginBtn.style.display = 'block';
                        signupBtn.style.display = 'block';
                        logoutBtn.style.display = 'none';
                        userInfo.style.display = 'none';
                    }
                } catch (err) {
                    console.error("Error in updateUIForUser:", err);
                    loginBtn.style.display = 'block';
                    signupBtn.style.display = 'block';
                    logoutBtn.style.display = 'none';
                    userInfo.style.display = 'none';
                }
            }

            (async () => {
                try {
                    await checkUserAndShowAgreement();
                } catch (error) {
                    console.error("Error during initial user check:", error);
                    showOverlay('agreementOverlay');
                }
            })();
        });
    </script>
        <!-- Leaderboard Detail Modal -->
        <div id="leaderboardDetailModal" class="menu-overlay" style="display: none;">
            <div class="menu-content" style="max-width: 600px; padding: 20px;">
                <h2 class="menu-title">Score Details</h2>
                <div id="detailContent" style="text-align: left; font-size: 0.9rem;">
                    <!-- Details will be populated here by JavaScript -->
                </div>
                <div class="menu-section" style="margin-top: 20px;">
                    <button id="closeDetailModalBtn" class="menu-btn">CLOSE</button>
                </div>
            </div>
        </div>
        <script>
            const closeDetailModalBtn = document.getElementById('closeDetailModalBtn');
            if (closeDetailModalBtn) {
                closeDetailModalBtn.addEventListener('click', () => {
                    document.getElementById('leaderboardDetailModal').style.display = 'none';
                });
            }
        </script>
    </body>
</html>
